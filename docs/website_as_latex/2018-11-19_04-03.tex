% File autogenerated using the Bonus 2 program at 2018-11-19 04:03
\documentclass[hidelinks,12pt,a4paper,numbers=enddot]{scrartcl}

\usepackage[margin=2cm]{geometry}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}

\title{Documentation}
\author{Group 1}
\begin{document}
\maketitle
\tableofcontents
\newpage

\section{wc}


\large Alessandro Luini \normalsize\\


The program reads either standard input or a list of files and
generates one or more of the following statistics: newline count,
word count, and byte count. If a list of files is provided, both
individual file and total statistics follow.

How to use
Sample execution of wc:

\begin{verbatim}
wc file1.txt file2.txt
\end{verbatim}

will output:

\begin{verbatim}
      40      149      947     file1.txt
    2294    16638    97724    file2.txt
    2334    16787    98671    total
\end{verbatim}

The first column is the count of newlines, meaning that the text file
\texttt{file1.txt} has 40 newlines while bar has 2294 newlines-
resulting in a total of 2334 newlines. The second column indicates the
number of words in each text file showing that there are 149 words in \texttt{file1.txt}
and 16638 words in \texttt{file2.txt} – giving a total of 16787 words.\\
The last column indicates the number of characters in each text file, meaning that the file
\texttt{file1.txt} has 947 characters while bar has 97724 characters – 98671
characters all in all.\\

Flags

\begin{verbatim}
wc -l file1.txt
\end{verbatim}

Prints the line count (note that if the last line does not have \texttt{\\n},
it will not be counted).

\begin{verbatim}
wc -c file1.txt
\end{verbatim}

Prints the byte count.

\begin{verbatim}
wc -m file1.txt
\end{verbatim}

Prints the character count.

\begin{verbatim}
wc -L file1.txt
\end{verbatim}

Prints the length of longest line (GNU extension)

\begin{verbatim}
wc -w file1.txt
\end{verbatim}

Prints the word count.

\section{vi}


\large Alessandro Luini \normalsize\\




The default editor that comes with the UNIX operating system is called
\texttt{vi} (visual editor).\\

The UNIX vi editor is a full screen editor and has two modes of operation:


\begin{itemize}
    \item Command mode commands which cause action to be taken on the file
    \item Insert mode in which entered text is inserted into the file.
\end{itemize}



In the command mode, every character typed is a command that does
something to the text file being edited; a character typed in the
command mode may even cause the vi editor to enter the insert mode.




In the insert mode, every character typed is added to the text in the
file; pressing the {Esc} (Escape) key turns off the Insert mode.




While there are a number of vi commands, just a handful of these
is usually sufficient for beginning vi users. To assist such users,
this Web page contains a sampling of basic vi commands. The most
basic and useful commands are marked with an asterisk (* or star)
in the tables below. With practice, these commands should become
automatic.




Both UNIX and vi are \textbf{case-sensitive}. Be sure not to use a
capital letter in place of a lowercase letter; the
results will not be what you expect.


How to start \texttt{vi}


To use vi on a file, type in vi filename. If the file named
filename exists, then the first page (or screen) of the file
will be displayed; if the file does not exist, then an empty
file and screen are created into which you may enter text.

\begin{verbatim}
vi filename.txt
\end{verbatim}

How to exit \texttt{vi}

Usually the new or modified file is saved when you leave vi.
However, it is also possible to quit vi without saving the file.\\

The cursor moves to bottom of screen whenever a colon (:) is
typed. This type of command is completed by hitting the
\textless Return\textgreater  (or \textless Enter\textgreater ) key.\\

\begin{verbatim}
:q
\end{verbatim}

Quit vi without saving

\begin{verbatim}
:x
\end{verbatim}

Quit vi, writing out modified file to
file named in original invocationt modified file to file named in origin.

\begin{verbatim}
:wq
\end{verbatim}

Quit vi, writing out modified file to file named in original invocation.

\begin{verbatim}
:q!
\end{verbatim}

Quit vi even though latest changes have not been saved for this vi call.


Recover from a crash

Open vi using the \texttt{-r} flag to recover a file that was being edited when a crash
happened.

\section{paste}


\large Agostino Monti \normalsize\\



The \texttt{paste} command is used to join files horizontally
(parallel merging) by outputting lines consisting of the sequentially corresponding
lines of each file specified, separated by tabs, to the standard output.\\
Once involved, \texttt{paste} will read all its file arguments. For each corresponding line,
paste will append the contents of each file at that line to its output along with a tab.
When it has completed its operation for the last file, \texttt{paste} will output a newline
character and move on to the next line.

\begin{verbatim}
paste [flags] [file1] [file2] ...
\end{verbatim}

Flags

\begin{itemize}
    \item \texttt{-d} delimiters, which specifies a list of delimiters to be used instead of tabs
        for separating consecutive values on a single line. Each delimiter is used in turn;
        when the list has been exhausted, paste begins again at the first delimiter.
\begin{verbatim}
paste -d "|" file1.txt file2.txt
paste -d "|," file1.txt file2.txt\end{verbatim}
    
    \item \texttt{-s}, which causes paste to append the data in serial rather than in parallel;
        that is, in a horizontal rather than vertical fashion.
    
\end{itemize}

\section{Pipes}


\large Domenico Votta \normalsize\\



The \texttt{pipes} that in the shell are representend with the symbol | ,
they are used to join two commands on the terminal, taking the output of the first
command and using it as input of the second.\\
It is usually common to see the command \texttt{grep} and \texttt{ps} together,
an example below.\\

Example: lists all processes with your username
\begin{verbatim}
ps aux | grep user
\end{verbatim}

Example: count the lines of a file, using the
\underline{\href{www.theshell.ch/pages/cmd/advanced/nl.html}{nl}} command
\begin{verbatim}
cat example1.txt | nl
    1  Car
    2  Computer
    3  Robot
    4  Smartphone
    5  Videogame
\end{verbatim}

Example: passing expressions to \underline{\href{www.theshell.ch/pages/cmd/advanced/bc.html}{bc}}
to do calculations
\begin{verbatim}
echo "(12 / 2 - 3) * 3 + 1.5" | bc
    10.5
\end{verbatim}

You can use the commands that you learned and put them together, always
respecting the logic of the command.

\section{colrm}


\large Domenico Votta \normalsize\\


The \texttt{colrm} is a command that removes the column that you indicate \\

Here we have a file named \texttt{example.txt} that contains two lines to test this command:\\

\begin{verbatim}
123456789
abcdefghi
\end{verbatim}

The syntax command is:
\begin{verbatim}
colrm [first] [last]
\end{verbatim}

\begin{verbatim}
colrm 4 \textless  example.txt
    123
    abc
\end{verbatim}

How you can see, if I don't indicate the last column, the command removes
all the colums starting from 4 included.
\begin{verbatim}
colrm 2 4 \textless  example.txt
    156789
    aefghi
\end{verbatim}

Here, how you can see, the command has removed not all the columns, but only the colums that
starting at 2 and ending at 4, included.

\section{head and tail}


\large Agostino Monti \normalsize\\



The \texttt{head} command reads the first few lines of any text given to it as an input
and writes them to standard output.\\
If more than one input file is provided, head will return the first ten lines
from each file, precede each set of lines by the name of the file and separate
each set of lines by one vertical space.

\begin{verbatim}
head [flags] [file1] [file2] ...
\end{verbatim}

The \texttt{tail} command is similar to the \texttt{head} command
except that it reads the final lines in files rather than the first lines.

\begin{verbatim}
tail [flags] [file1] [file2] ...
\end{verbatim}

Flags

\begin{itemize}
    \item \textbf{-n}: can be used followed by number, which indicates the number of
        lines desired in the output. This flag can be used without \emph{n}: the hyphen and the
        number (with no intervening space) are enough to tell head how many lines to return.
\begin{verbatim}
head -n15 file1.txt \\
head -n 15 file1.txt \\
head -15 file1.txt\end{verbatim}
    
    \item \textbf{-c}: similar to \emph{-n} with the only difference being that the number stands for
        bytes instead of the number of lines and the fact that it can't be used without explicitly
        typing the \emph{-c}.
    
\end{itemize}

\section{emacs}


\large Alessandro Luini \normalsize\\



Emacs is one of the oldest and most versatile text editors available for
UNIX-based systems. It's been around for a long time (more than twenty years
for GNU emacs) and is well known for its powerful and rich editing features.\\
Emacs is also more than just a text editor; it can be customized and
extended with different "modes", enabling it to be used like an
Integrated Development Environment (IDE) for programming languages
like Java, C or Python.\\

For those who have used both the ubiquitous vi and the user-friendly nano,
emacs would come as an interesting cross-between. Its strengths and features
would resemble those of vi while its menus, help files and easy-to-remember
command-keys would compare with nano.\\

In this article, we will see how we can install emacs
in a Linux system and use it for basic text editing. Emacs
is also available for graphical window managers, however we will only cover the
"text based" version here.

Open a file, or create it like this:

\begin{verbatim}
    emacs file1.txt
\end{verbatim}

And then follow the simple manual that will be open.

\section{grep}


\large Domenico Votta \normalsize\\


The \texttt{grep}  is a command that permits to search occurences of a
keyword or more in a file or more. Through some flags you can decide the search criteria.
The command grep is case sensitive (robot is different from Robot), but we will see how
to ignore it.\\

Here we have two files named \texttt{example1.txt} and
\texttt{example2.txt} that contain 5 elements, to test this command:

\texttt{example1.txt}
\begin{verbatim}
Car
Computer
Robot
Smartphone
Videogame
\end{verbatim}

\texttt{example2.txt}
\begin{verbatim}
Apple
Computer
Robot
Microsoft
Huawei
\end{verbatim}

The syntax command is:
\begin{verbatim}grep [flag] [keyword] [file]\end{verbatim}
You can put different flags together to refine the search.

\begin{verbatim}
grep Robot example1.txt example2.txt (if you write robot you won't have the correspondence.)
    example1.txt: Robot
    example2.txt: Robot
\end{verbatim}

Your output will be this because grep found the keyword Robot in both files

\subsubsection{Flags}

Here a list that contains the main flags of these command:

\begin{itemize}
    \item  \textbf{-i}: this flag ignore the case sensitive. Here we can write Robot or
        robot that grep will find the correspondence.
\begin{verbatim}
grep -i robot example1.txt example2.txt
    example1.txt: Robot
    example2.txt: Robot
\end{verbatim}
    

    \item  \textbf{-v}: this flag ignore the keyword from the search.
\begin{verbatim}
grep -i -v robot example1.txt example2.txt
    example1.txt:Car
    example1.txt:Computer
    example1.txt:Smartphone
    example1.txt:Videogame
    example2.txt:Apple
    example2.txt:Computer
    example2.txt:Microsoft
    example2.txt:Huawei
\end{verbatim}
    

    \item  \textbf{-c}: this flag indicates the number of times that the keyword appears in the file.
\begin{verbatim}
grep -i -c robot example1.txt
    1
\end{verbatim}
    (If in the file you would have had two times the keyword Robot, the output would have been 2)
    

    \item  \textbf{-h}: Remove from the output the file name where it found the keyword
\begin{verbatim}
grep -i -h apple example1.txt example2.txt
    Apple
\end{verbatim}
    How you can see the output doesn't show tha file name \texttt{example2.txt}
    
\end{itemize}

\section{bc}


\large Alessandro Luini \normalsize\\



In computing, \texttt{bc} is a command in Unix operating systems that can do easy
calculations in the shell.\\
Usually input are passed using the \texttt{echo} command and pipes.
The name stands for \emph{Basic Calculator}.\\

\begin{verbatim}
echo "(12 / 2 - 3) * 3 + 1.5" | bc
    10.5
\end{verbatim}

Interactive mode

Using the interactive mode makes you do calculations freely in a special shell inside the shell.
All you need to do is run the bc command with the \texttt{-i} flag
and no parameter.\\
To exit the interactive mode, write \emph{quit}.

\begin{verbatim}
bc -i

1+1
    2
(12 / 2 - 3) * 3 + 1.5
    10.2
quit
\end{verbatim}

\section{nl}


\large Domenico Votta \normalsize\\


The \texttt{nl} is a command that permits to number the lines.
Through some flags you can decide how to filter this command.\\

We have a file named \texttt{example.txt} that contains 5 elements, to test this command:

\begin{verbatim}
Car
Computer
Robot
Smartphone
Videogame
\end{verbatim}

The syntax command is:
\begin{verbatim} nl [flags][file] \end{verbatim}

\begin{verbatim}
nl example.txt
    1  Car
    2  Computer
    3  Robot
    4  Smartphone
    5  Videogame
\end{verbatim}

How you can see the command has numbered the lines.

\subsubsection{Flags}


\begin{itemize}
    \item  \textbf{-b (regex)}: Specify the lines to be numered
\begin{verbatim}
nl -b p\^[cv] example.txt
    1  Car
    2  Computer
    3  Videogame
       Robot
       Smartphone
\end{verbatim}
    The part after the flag is used to number only the lines that start with c and v.
    

    \item  -b\textbf{n}: The flag n goes with b, doesn't number any lines
\begin{verbatim}
nl -bn example.txt
    Car
    Computer
    Videogame
    Robot
    Smartphone
\end{verbatim}
    

  \item  \textbf{-s}: Usually nl separes the number of the line from the text with a tab, with -s
      flag you can choose another separator, in this example we will use "=".
\begin{verbatim}
nl -s= example.txt
    1=Car
    2=Computer
    3=Videogame
    4=Robot
    5=Smartphone
\end{verbatim}
    

\end{itemize}

\section{echo}


\large Alessandro Luini \normalsize\\



In computing, \texttt{echo} is a command in Unix operating systems that outputs the
strings it is being passed as arguments.\\

It is a command typically used to output status text to the screen or a
computer file, or as a source part of a pipeline.\\

To use this simple command just type "echo" with the topic we want to
print. The computer will return your argument as a string

\begin{verbatim}
echo "hello world"
    hello world
\end{verbatim}

\section{comm}


\large Domenico Votta \normalsize\\


The \texttt{comm} is a command that compares two sorted files
line by line and writes the output: the lines that are in common and the lines that are unique.\\

Here we have two files named \texttt{example1.txt} and
\texttt{example2.txt} that contain 5 elements, to test this command:\\

\texttt{example1.txt}
\begin{verbatim}
Icecream
Chocolate
Cake
Candy
Biscuit
\end{verbatim}

\texttt{example2.txt}
\begin{verbatim}
Bread
Chocolate
Tomato
Candy
Pizza
\end{verbatim}

The syntax command is:
\begin{verbatim}
comm [flag][file1] [file2]
\end{verbatim}

\begin{verbatim}
comm example1.txt example2.txt
    Icecream
        Chocolate
    Cake
      Tomato
        Candy
    Biscuit
      Pizza
\end{verbatim}

\begin{itemize}
    \item The elements of the first file have less indentation.
    \item The elements of the second file have some more indentation.
    \item The elements in common have even more indentation than those of the second file.
\end{itemize}

Flags

\begin{itemize}
  \item  \textbf{-1}: supress column 1
  \item  \textbf{-2}: supress column 2
  \item  \textbf{-3}: supress column 3
\end{itemize}

\section{diff}


\large Alessandro Luini \normalsize\\



The command \texttt{diff} analyzes two files and prints the lines that are different.
Essentially, it outputs a set of instructions for how to change one file to
make it identical to the second file.\\

How to use

To activate the diff command, we must take as parameters two or more
files that we want to compare and it will give us the output of
different lines.\\
For example let's say we have two files, file1.txt and file2.txt.\\
If \textbf{file1.txt} contains the following four lines of text:

\begin{verbatim}
1. I need to buy apples.
2. I need to run around the park.
3. I need to clean the dog.
4. I need to get the car detailed.
\end{verbatim}

and \textbf{file2.txt} contains these four lines:

\begin{verbatim}
1. I need to do the laundry.
2. I need to clean the dog.
4. I need to get the dog detailed.
\end{verbatim}

then we can use diff to automatically display for us which lines differ
between the two files with this command:

\begin{verbatim}
diff file1.txt file2.txt
\end{verbatim}

and the output will be:

\begin{verbatim}
2,4c2,4

    \textless  I need to run the laundry.
    \textless  I need to wash the dog.
    \textless  I need to get the car detailed.
    ---
    \textgreater  I need to do the laundry.
    \textgreater  I need to wash the car.
    \textgreater  I need to get the dog detailed.
\end{verbatim}

In our output, "2,4c2,4" means: "Lines 2 through 4 in the first
file need to be changed to match lines 2 through 4 in the second file.

Context mode
To view differences in context mode, use the -c option.
For instance, let's say \emph{file1.txt} and \emph{file2.txt} contain
the following:\\

\begin{table}[h]
\begin{tabular}{ll}
    File1.txt &File2.txt \\
    apples &apples \\
    oranges &kiwis \\
    kiwis &carrots \\
    carrots &grapefruits \\
\end{tabular}
\end{table}

\begin{verbatim}
diff -c file1.txt file2.txt
\end{verbatim}

Our output will be like the following:

\begin{verbatim}
*** file1.txt   2014-08-21 17:58:29.764656635 -0400
--- file2.txt   2014-08-21 17:58:50.768989841 -0400
***************
*** 1,4 ****
  apples
- oranges
  kiwis
  carrots
--- 1,4 ----
  apples
  kiwis
  carrots
+ grapefruits
\end{verbatim}

The first two lines of this output show us information about our "from"
file (file 1) and our "to" file (file 2). It lists the file name,
modification date, and modification time of each of our files, one per
line. The "from" file is indicated by "***", and the "to" file is
indicated by "---"..\\

The line "***************" is just a separator.\\
The next line has three asterisks ("***") followed by a line
range from the first file (in this case lines 1 through 4, separated by
a comma). Then four asterisks ("****").\\
Then it shows us the contents of those lines. If the line is unchanged,
it's prefixed by two spaces. If the line is changed, however, it's prefixed
by an indicative character and a space. The character meanings are as
follows:

\begin{table}[h]
\begin{tabular}{ll}
    Character &Meaning \\
    \textbf{!} &
            Indicates that this line is part of a group of one or more lines that
            needs to change. There is a corresponding group of lines prefixed with
            "!" in the other file's context as well.
         \\
    \textbf{+} &Indicates a line in the second file that needs to be added to the first file. \\
    \textbf{-} &Indicates a line in the first file that needs to be deleted. \\
\end{tabular}
\end{table}

After the lines from the first file, there are three dashes ("---"),
then a line range, then four dashes ("----"). This indicates the
line range in the second file that will sync up with our changes
in the first file.

If there is more than one section that needs to change, diff will
show these sections one after the other. Lines from the first file will
still be indicated with "***", and lines from the second file
with "---".

Unified mode
Unified mode (the -u option) is similar to context mode,
but it doesn't display any redundant information. Here's an example,
using the same input files as our last example:

\begin{verbatim}
diff -u file1.txt file2.txt
\end{verbatim}

will output:

\begin{verbatim}
--- file1.txt   2014-08-21 17:58:29.764656635 -0400
+++ file2.txt   2014-08-21 17:58:50.768989841 -0400
@@ -1,4 +1,4 @@
 apples
-oranges
 kiwis
 carrots
+grapefruits
\end{verbatim}

The output is similar to above, but as you can see, the differences are
"unified" into one set.

\section{tr}


\large Alessandro Luini \normalsize\\



The \texttt{tr} command in Unix-like operating systems, which name stands for
\emph{TRanslate} or \emph{TRansliterate}, indicating its operation of replacing or removing
specific characters in its input data set.

How to use

The utility reads a byte stream from its standard input and writes the
result to the standard output. As arguments, it takes two sets of
characters (generally of the same length), and replaces occurrences of
the characters in the first set with the corresponding elements from the
second set.\\

For example,
\begin{verbatim}
tr 'abcd' 'jkmn'
\end{verbatim}

would maps all characters a to j, b to k, c to m, and d to n.\\
The character set may be abbreviated by using character ranges. The
previous example could be also written as:

\begin{verbatim}
tr 'a-d' 'jkmn'
\end{verbatim}


Flags
\begin{itemize}
    \item  \textbf{-s}: The s flag causes tr to compress sequences of identical
        adjacent characters in its output to a single token.
\begin{verbatim}
tr -s '\\n'
\end{verbatim}
        replaces sequences of one or more newline characters with a single
        newline.
    
    \item  \textbf{-d}: The d flag causes tr to delete all tokens of the specified
        set of characters from its input. In this case, only a single character
        set argument is used. The following command removes carriage return
        characters.
\begin{verbatim}
tr -d '\r'
\end{verbatim}
    
\end{itemize}

\section{install}


\large Marco Farace \normalsize\\



The file(s) are copied to the target file or directory. If the destination
is a directory, then the file is copied into directory with its original
filename.  If the target file already exists, it is either renamed to
file.old if the -b option is given or overwritten if permissions allow.\\
An alternate backup suffix may be specified via the -B option's argument.\\
Basic syntax is in the form

\begin{verbatim}
install [OPTION]... SOURCE DEST
\end{verbatim}

This line of code copies all .xyz file from \emph{/source/folder} to \emph{/destination/folder}

\begin{verbatim}
install -D /source/folder/*.xyz /destination/folder
\end{verbatim}

Flags

\begin{itemize}
    \item -b: Back up any existing files before overwriting them by renaming
        them to file.old.  See -B for specifying a different backup suffix.
        (-B suffix Use suffix as the backup suffix if -b is given)
    \item -C: Copy the file.  If the target file already exists and the files
        are the same, then don't change the modification time of the target
    \item -d: Create directories.  Missing parent directories are created as required.
    \item -f: Specify the target's file flags; see chflags(1) for a list of
        possible flags and their meanings.
    \item -g: Specify a group.  A numeric GID is allowed.
    \item -m: Specify an alternate mode.  The default mode is set to rwxr-xr-x
        (0755). The specified mode may be either an octal or symbolic
        value.
    \item -o: Specify an owner.  A numeric UID is allowed.
\end{itemize}

\section{7z}


\large Andrea Brites Marto \normalsize\\




A .7z. file is an archive format that stands for 7-zip. By default, Mac OS X does not
know how to handle these files, but that is not a big deal because you can download for
free in App Store. The program supports 7z, ZIP, CAB, ARJ, BZIP2, TAR, CPIO, RPM and DEB.\\

So, first of all, you need to download Unarchiver in order to use this command.\\

The basic syntax is:

\begin{verbatim}
7z [adeltux] [-] [SWITCH] \texttt{\textless ARCHIVE_NAME\textgreater  \textless ARGUMENTS\textgreater }
\end{verbatim}

Here some useful options that we will use to explain some examples:

\begin{itemize}
    \item \emph{a} Add
    \item \emph{d} Delete
    \item \emph{e} Extract
    \item \emph{l} List
    \item \emph{t} Test
    \item \emph{u} Update
    \item \emph{x} Extract with full paths
\end{itemize}

The simplest way to use \texttt{7z} if we want to extracts all files
from archive archive.zip to the current directory.

\begin{verbatim}
7z e archive.zip
\end{verbatim}


Well, now we talk about the switches.
There are many type of switches, we will see the most common ones.

-m (Set compression Method)


Specifies the compression method

\begin{verbatim}
-m\textless method_parameters\textgreater 
\end{verbatim}

The format for this switch depends on the archive type which are:
\begin{itemize}
    \item Zip
    \item GZip
    \item BZip2
    \item 7z
    \item XZ
    \item WIM
\end{itemize}

-r (Recurse subdirectories) switch


Specifies the method of treating filenames or wildcards on the command line.
The syntax:

\begin{verbatim}
-r[- | 0]
\end{verbatim}

\begin{table}[h]
\begin{tabular}{ll}
    Switch &Description \\
    -r &Enable recurse subdirectories \\
    -r- &Disable recurse subdirectories. This is the default option. \\
    -r0 & Enable recurse subdirectories only for wildcard names  \\
\end{tabular}
\end{table}



If we want to list all *.doc files that belong to the archived root directory in
the \emph{archive.zip} archive, we can do as follows:


\begin{verbatim}
7z l archive.zip *.doc -r-
\end{verbatim}

-p (Set password) switch


Specifies a password
Here the syntax is very simple:

\begin{verbatim}
-p{password}
\end{verbatim}

If we want to protect some files we can compress for example all *.txt files
to archive.7z using a password as "cimbale".

\begin{verbatim}
7z a archive.7z -p cimbale
\end{verbatim}

Then if we want to extracts all files from archive.7z we need the password "cimbale".

\begin{verbatim}
7z x archive.7z -p cimbale
\end{verbatim}

-x (Exclude filenames) switch 



Specifes which filenames or wildcards must be excluded from the operation.


Syntax:

\begin{verbatim}
-x[\textless recurse_type\textgreater ]\textless file_ref\textgreater 
\end{verbatim}

Sometimes we need to add files into an archive.7z, except one, this can be done as fllows:

\begin{verbatim}
7z a -tzip archive.7z *.txt -x!temp.*
\end{verbatim}


We described the most important swtiches and uses of this command, but there are more.

\section{md5}


\large Joey Bevilacqua \normalsize\\



The command \texttt{md5} calculates an unique string for each input given as
argument using the \emph{md5} algorithm.

\begin{verbatim}
md5 [flags] [arg1] [arg2]
\end{verbatim}

Where \[flags\] are the (optional) md5 flags, read below for more info,
and \[arg1\], \[arg2\] are the path for files or string (depending on the flags).

Example: md5 sum of the string \emph{Hello there}

\begin{verbatim}
md5 -s "Hello there"
    MD5 ("Hello there") = e8ea7a8d1e93e8764a84a0f3df4644de
\end{verbatim}

Flags

\begin{itemize}
    \item \textbf{-s}: computes the md5 sum of a string instead of a file
    \item \textbf{-q}: prints the md5 sum without the file or string name
    \item \textbf{-r}: reverses the format of the output
\end{itemize}

\section{bash}


\large Marco Farace \normalsize\\



Bash is an sh-compatible command language interpreter that executes commands
read from the standard input or from a file. Bash also incorporates useful
features from the Korn and C shells (ksh and csh).\\

Flags
\begin{itemize}
    \item -c: If this option is present, then commands are read from
        string.  If there are arguments after the string, they are
        assigned to the positional parameters, starting with \$0.
    
    \item -i: If this option is present, the shell is interactive.
    \item -l: Make bash act as if it had been invoked as a login shell.
    \item -r: If this option is present, the shell becomes restricted.
    \item -s: If this option is present, or if no arguments remain after
        option processing, then commands are read from  the  standard
        input.   This  option  allows the positional parameters to be
        set when invoking an interactive shell.
    
    \item -s: List only the name, line and time fields.  This is the default.
    \item -T: Print a character after the user name indicating the state of the
        terminal line: `+' if the terminal is writable; `-' if it is not;
        and `?' if a bad line is encountered.
    
    \item -u: Print the idle time for each user, and the associated process ID.
    \item am I: Returns the invoker's real user name.
    \item file: By default, who gathers information from the file /var/run/utmpx.
        An alternative file may be specified.
    
\end{itemize}

\section{git}


\large Andrea Brites Marto \normalsize\\


If you want to use \emph{Git} on the shell you need to know how this command works.\\
The \emph{git} command providesa set of high-level operations and full access to internals.\\

Here is the basic syntax but commands may become some more complicated:

\begin{verbatim}
git [flags] [path]
\end{verbatim}

Start a working environment

\begin{itemize}
    \item \textbf{clone}: is used to clone a repository in a new directory.
    \item \textbf{init}: this onw is used to create an empty Git repository or reinitialize
        an existing one.
    
\end{itemize}

Work on the current changes
\begin{itemize}
    \item \textbf{add}: add a file contents to the index.
    \item \textbf{mv}: move or renamea file, directory or a symlink (a symbolic link).
    \item \textbf{rm}: remove files from the working tree and from the index.
    \item \textbf{format-patch id}: create a file patch
    \item \textbf{am}: apply a patch file
\end{itemize}

History and state
\begin{itemize}
    \item \textbf{log}: show commit logs.
    \item \textbf{status}: show the working tree status.
\end{itemize}

Managing modification
\begin{itemize}
    \item \textbf{commit}: record changes to the repository.
    \item \textbf{diff}: show changes between commits.
    \item \textbf{merge}: merge two or more development histories together.
    \item \textbf{pull}: fetch from and update your local directory with the repository.
    \item \textbf{push}: update the remote repository with your changes.
\end{itemize}

\section{ping}


\large Joy Albertini \normalsize\\





The \texttt{ping} command, is used to test connection between a \textbf{local server/computer}
to a \textbf{remote UNIX server}.\\
The ping command sends \textbf{ICMP Echo Request packets} to the remote server for accessing it.
Each \textbf{packet echoed back } (via an ICMP Echo Response packet) is written to the shell output.

\begin{verbatim}
  ping [-flag] server
\end{verbatim}

The main usages for the \texttt{ping} command are:

\begin{itemize}
    \item Test whether remote server if working.
    \item Check the network connectivity from your local machine to a remote one.
    \item Check for general network issues.
\end{itemize}

\begin{verbatim}
ping theshell.ch
\end{verbatim}

The shell will output something like this:
\emph{64 bytes from 98.138.219.232: icmp\_seq=0 ttl=49 time=144.781 ms} for each packet
that returns (echoed back).\\

To stop the ping command press \texttt{control + c}.

Flags

\begin{itemize}
    \item \textbf{-c}: send limited number of packets with ping -c (nr of packets)\\
        Example: ping -c 4 yahoo.com, the shell will display the first 4 packets returned,
        and then stop.
    
    \item \textbf{-n}: avoid dns lookup, avoid to lookup symbolic names for host addresses,
        so only numeric output.
    
    \item \textbf{-a}: get an audio warning, when the remote server comes online \\
        Example: ping -a yahoo.com, server comes online audio signal for every
        packets that returns.
    
    \item \textbf{-b}: Allow pinging a broadcast address (broadcast network, is a network
        with many devices on it).
    
    \item \textbf{-m}: (mark) tag the packets going out.
    \item \textbf{-f}: (Flood ping) For every ECHO\_REQUEST sent (.) is printed,
        for every ECHO\_REPLY received, a backspace is printed.
        With this command you can easily understand how many packets are being dropped.
    
    \item \textbf{-i}: (interval) set the interval between seending each packet (default 1 second);
        only super-user can set interval values less than 0.2 seconds.
    
    \item \textbf{-I}: (interface-address) set souce adress to a specific interface adress,
        example the name of the device or IP. When pinging local adresses IPV6, is a needed flag.
    
    \item \textbf{-l}: (preload) ping send packets but don't wait for reply.
        Admin permissions are required to use this flag.
    
    \item \textbf{-L}: Remove loopback of multicast packets.
    \item \textbf{-N}: (Nioption) send ICMpv6 request, instead of Echo requests
        \begin{itemize}
            \item \textbf{ipv6}: request Ipv6 adresses.
            \item \textbf{ipv4-all}: request Ipv4 adresses.
        \end{itemize}
    
    \item \textbf{-p}: (pattern) specify up to 16 number to fill out the packets sent.
    \item \textbf{-D}: print timestamp (unix time + microseconds) in each line.
    \item \textbf{-q}: (Quiet output) Nothing  displayed except the summary lines at the start
        and at the end.
    
    \item \textbf{-R}: (Record route), displays the route buffer on the packets that include
        RECORD\_ROUTE in the ECHO\_REQUEST.
    
    \item \textbf{-r}: bypass the normal routing in a directly-attached network.
    \item \textbf{-s}: (packetsize) Specifies the data bytes to send (default is 56 that
        + 8 byte of ICMP = 64 ICMP data bytes).
    
    \item \textbf{-t}: set IP time-to-live (set how long execute ping in seconds).
    \item \textbf{-U}: print full user-to-user latency (legacy ping behaviour).
    \item \textbf{-v}: output verbose on output
    \item \textbf{-V}: Display verion of command
    \item \textbf{-w}: (deadline) Timeout in seconds of ping command, regardless of how\
        many packets have been sent.
    
    \item \textbf{-W}: (timeout), time waiting for a response from the server, if the server
        dosen't reply in the time set, the ping command will stop.
    
\end{itemize}

\section{shasum}


\large Gianmarco De Vita \normalsize\\



With \texttt{shasum} command you can work with SHA Checksums.

\begin{verbatim}
shasum [flag] [file]
\end{verbatim}

Store the Checksum

You can store the output in a file by adding to the command line the string
output symbol "\textgreater " and then the path and the name of the file.\\

Define the algorithm

The flag \texttt{-a} allows you to choose which algorithm to use when
defining the checksum of a file. The default algorithm is 1.

\begin{verbatim}
shasum -a algorithm file
\end{verbatim}

Read in binary mode

The flag \texttt{-b} allows you to read files in binary mode.

\begin{verbatim}
shasum -b file.bin
\end{verbatim}

Check two SHA sums

You can verify wheter two checksums belong to the same file or not (and so
define wheter the two files are the same thing) wit the flag \texttt{-c}.
After storing the Checksums into two files (let say file1 and file2),
you can write to command as follows:

\begin{verbatim}
shasum -c shaSum1 shaSum2
\end{verbatim}

Display help

Writing the command followed by the \texttt{-h} h flag will display a little
help paragraph with the main functions of this command.

\begin{verbatim}
shasum -h
\end{verbatim}

\section{basename}


\large Fabiano Fenini \normalsize\\


The \texttt{basename} command deletes any prefix ending with the last slash "/" character
present in string and also a suffix.

Usage
The default basename command syntax is:

\begin{verbatim}
basename [flags] [string] [suffix]
\end{verbatim}

Where \[flags\] are the cat flags, read below for more info, the string command is
the pathname and the suffix, if indicated, will be also deleted.\\

Flags

Here are some of the most common basename flags:

\begin{itemize}
    \item \textbf{-a}: Every aregument is treated as a string 
    \item \textbf{-s}: The suffix is taken as its argument  
    \item \textbf{-a}: Supports multiple arguments and they will be treated as a name 
\end{itemize}

Example

\begin{verbatim}
basename /USI/command
\end{verbatim}

The shell will output this:

\begin{verbatim}
command
\end{verbatim}

\section{base64}


\large Gianmarco De Vita \normalsize\\



\emph{Base64} is an encoding system that allows the translation of binary
data into ASCII text strings, basing upon 64 different ASCII characters.\\
Each \emph{Base64} digit represents exactly 6 bits of data so, for example,
six bytes (a total of 48 bits) can be represented by eight \emph{Base64} digits.

By writing the command \texttt{base64} you can encode and decode Base64 data.
The command follows the structure:

\begin{verbatim}
base64 [flag] [-i input item] [-o output item]
\end{verbatim}

Defining input and output files
In this case, flag such as \texttt{-i} and \texttt{-o} are fundamental
to define respectevely from which file take the stream and into which to store
the result. Naturally, the path and the name of the files must be specified.

\begin{verbatim}
base64 -i path/input.file -o path/output.file
\end{verbatim}

Insert line breaks
Using the \texttt{-b} (which stands for \emph{break}) flag followed by a
number, line breaks are added every specified "number" characters.

\begin{verbatim}
base64 -b number path/input.file path/output.file
\end{verbatim}

By leaving the number field empty, an unbroken stream will be generated.

Decode Base64
Using the \texttt{-D} flag (which stands for decode), you obtain as
output the input message decoded into binary data.

\begin{verbatim}
base64 -D [-i input item] [-o output item]
\end{verbatim}

Summarize the tools
Using the \texttt{-h} (which stands for \emph{help}) a short paragraph
in which are listed the flags with the respective paragraph will be displayed.

\begin{verbatim}
base64 -h
\end{verbatim}

\section{caffeinate}


\large Joao Tomazoni \normalsize\\



The \texttt{caffeinate} command prevents the computer to go into sleep mode,
just as if you would set it to never sleep in the system preferences.
Type \texttt{caffeinate -d} in your terminal and it will prevent your screen to sleep
without changing the system preferences.

\begin{verbatim}
caffeinate -d
\end{verbatim}

You can also prevent your computer to go sleep while another process is taking place, but turn sleep
mode on again when the process is over, for that you use the same code as above, and then type the
arguments you want to run and prevent computer to go on sleep mode. For example, say you have a
big file on your desktop that you want to md5, and you want to prevent your computer to enter
the sleep mode:

\begin{verbatim}
caffeinate -d ~/Desktop/bigfile
\end{verbatim}

Doing so, your computer is now prevent to enter on sleep mode while the md5 process is running,
and automatically turn the sleep mode on again when the process is completed.

\section{chroot}


\large Gianmarco De Vita \normalsize\\


The \texttt{chroot} utility allows you to change its root directory to
the one indicated in newroot and, if given, executes the command.\\

\begin{verbatim}
chroot newroot [command]
\end{verbatim}

\section{watch}


\large Claudio Maggioni \normalsize\\


The \texttt{watch} command is a system utility able to execute a command
every \emph{n} seconds by clearing the screen and displaying the
output of the command each time the interval is over. This command is very
simple to use and very effective: it can be used to check the size in bytes
of a file while downloading it, or it can be used on \emph{Linux} to jiggle
around the mouse every ~5 minutes with the command \texttt{xdotool} in
order to keep the computer awake.

Usage

\texttt{watch} has a very simple syntax: the amount in seconds to wait
between executions is specified in seconds using the \texttt{-n} flag
and the default value is \emph{2}. Also, differences between older and
newer outputs are highlighted if the \texttt{-d} flag is used.

Example: Watch the size of "ubuntu.iso" every 5 seconds

\begin{verbatim}
watch -n 5 du -h ubuntu.iso
\end{verbatim}

Example: Watch the contents of "site.html" every 2 seconds and highlight the
differencies between iterations

\begin{verbatim}
watch -d cat site.html
\end{verbatim}

\section{ifconfig}


\large Matteo Omenetti \normalsize\\



The command \texttt{ifconfig} stands for \emph{Interface CONFIGuration}. It is used
to configure, control, and query network interface parameters of your system.\\
If you try running this command with no arguments, it will simply display information
about all network interfaces currently active.\\

\begin{verbatim}
    ifconfig
\end{verbatim}

The output sill resembles something like this, of course it changes from machine
to machine:

\begin{verbatim}
en5: flags=8863 UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST mtu 1500
    ether ac:de:48:00:11:22
    inet6 fe80::aede:48ff:fe00:1122\%en5 prefixlen 64 scopeid 0x8
    nd6 options=201 PERFORMNUD,DAD
    media: autoselect (100baseTX full-duplex)
    status: active

ap1: flags=8802 BROADCAST,SIMPLEX,MULTICAST mtu 1500
    ether f2:18:98:41:74:42
    media: autoselect
    status: inactive
    ...
\end{verbatim}

If you want to view the configuration of all network interfaces, not just the ones
currently active, you can use flag \texttt{a}.

\begin{verbatim}
ifconfig -a
\end{verbatim}

If you want to view the configuration of a specific interface, you can specify
the name of the interface you want to view after the command \emph{ifconfig}:

\begin{verbatim}
ifconfig ap1
\end{verbatim}

This command will show only the configuration of ap1.\\

To enable an interface, you can use the command ifconfig with the name of the interface
you want to enable, followed by the key word \texttt{up}.\\

However, enabling or disabling a device, is a privilege reserved for the super user,
therefore you also have to use the command \texttt{sudo}.

\begin{verbatim}
   sudo ifconfig ap1 up
\end{verbatim}

To disable an interface, you can follow the same procedure, this time using
the key word \texttt{down}.

\begin{verbatim}
   sudo ifconfig ap1 down
\end{verbatim}

\section{tar}


\large Nicola Brunner \normalsize\\



The \texttt{tar} command is used to create and manipulate streaming archive files, in
other words it is used to compress and extract files and directories. He can
extract from many file formats like: tar, pax, cpio, zio, jar, ar and ISO 9660
cdrom images and create tar, pax, cpio, ar, and shar archives.\\

Usage:

There are different syntaxes for this command:

\begin{verbatim}
tar {-c} [options] [files | directories]
\end{verbatim}

The first one is the default syntax. Where \texttt{{-c}} stays for the
creation of a new archive, \texttt{\[options\]} for the different flags that
we can use, \texttt{\[files | directories\]} for the files or directories
what we want to compress.

\begin{verbatim}
tar {-r | -u} -f archive-file [options] [files | directories]
tar {-t | -x} [options] [patterns]
tar [bundled-flags args] [file | pattern ...]
\end{verbatim}

The last one shows a bundled option word provided for compatibility with
historical implementations.\\

Flags:

This command has a large number of options, but you just need to remember a
few letters for the most important ones:

\begin{itemize}
    \item \texttt{-c} creates a new archive, that contains the specified items.
    \item \texttt{-r} is like \texttt{-c} but appends the new entries to the
        archive, requires the \texttt{-f} option.
    
    \item \texttt{-u} is like \texttt{-r} but adds the new entries only if
        the date is newer than the corresponding entry date of the file/directory to
        the archive, requires the \texttt{-f} option.
    
    \item \texttt{-t} lists the archive contents to the terminal output.
    \item \texttt{-v} is used to display the progress of an archive creation in
        the terminal.
    
    \item \texttt{-f} allows to specify the name of an archive.
    \item \texttt{-x} is used to extract files from an archive to the disk.
    \item \texttt{--exclude} does not compress specified files or directories.
    \item \texttt{--include} compresses specified file or directories. It's
        important to know that \texttt{--exclude} take precedence over inclusions.
        The \texttt{--include} option is useful when you want to filter archives.
    
\end{itemize}

If you don't find here an option that you search, or you are interested to read
more about this command, you can write in your terminal:

\begin{verbatim}
man tar
\end{verbatim}

Examples

\begin{verbatim}
tar -cvf archive.zip makesmaller.jpg
\end{verbatim}

In this case, we take the file \texttt{makesmaller.jpg} and compress it
to \texttt{archive.zip}. We use the options \texttt{-cvf}, \texttt{-c }
for creating a new archive, \texttt{-v} for displaying the progress of the
operation and \texttt{-f} for specifying the name of the archive.

\begin{verbatim}
tar -cvf archive.zip makesmaller.jpg alsome.txt
\end{verbatim}
It's the same case as before, but we wanted to add also \texttt{alsome.txt}
to \texttt{archive.zip}.

\begin{verbatim}
tar -cvf archive.tar /home/Documents --exclude=/home/Documents/PrivatePictures --exclude=/home/Documents/notme.txt
\end{verbatim}

With this command we can create an archive named \texttt{archive.tar} of
the \texttt{/home/Documents directory}, but we won't include the
\texttt{PrivatePictures} directory and the file \texttt{notme.txt},
both are contained in \texttt{/home/Documents}.

\begin{verbatim}
tar -cvf archive.tar /home/Music --exclude=*.mp4
\end{verbatim}

In this special case we exclude from the \texttt{archive.tar}all the
files which ends in .mp4 and are contained in the directory \texttt{/home/Music}.

\begin{verbatim}
tar -cvf archive.zip /home/Music --include=*.mp3
\end{verbatim}

In this case we include only the files from the directory \texttt{/home/Music}
that ends in .mp3 to the \texttt{archive.zip}.

\begin{verbatim}
tar -xvf archive.zip
\end{verbatim}
It's the same as the archive creation command we used above in the first
example, except the \texttt{-x} option replaces the \texttt{-c} option.
This specifies you want to extract an archive instead of creating one.

\section{strings}


\large Marco Farace \normalsize\\





The strings command returns each string of printable characters (ASCII)
in files. Its main uses are to determine the contents of and to extract text
from binary files (i.e., non-text files). From the Shell manual: "find the
printable strings in a object, or other binary, file".




Strings can be used to extract character information and string of a given length
from text file(s). When used without any options, strings displays all strings
that are at least four characters in length in the files whose names are
supplied as arguments (i.e., input data). Strings that are on separate lines
in the input files are shown on separate lines on the screen, and an attempt
is made to display all strings found on a single line in a file on a single
line on the screen (although there may be a carryover to subsequent lines in
the event that numerous strings are found on a single line). strings looks in
all sections of the object files except the (\_\_TEXT,\_\_text) section.


\begin{verbatim}
strings [options] file_name(s)
\end{verbatim}

Flags

\begin{itemize}
    \item -n: Specify the minimum string length, where the number argument is
        a positive decimal integer. The default is 4.
    \item -: This  option  causes strings to look for strings in all bytes of
        the files (the default for non-object files).
    \item --: This option causes strings to treat all the following  arguments
        as files.
    \item -a: This option causes strings to look for strings in  all  sections
        of the object file (including the (\_\_TEXT,\_\_text) section.
\end{itemize}

\section{scp}


\large Announ Marwan \normalsize\\



The \texttt{scp} command name stands for \emph{Secure CoPy}.\\
As the name suggests it's similar to the \texttt{cp} command,
with the main difference being that while \texttt{cp} is used to move files
in a local machine, \texttt{scp} will also operate on the remote systems.\\

The syntax is similar to the one of the \texttt{cp} command.

\begin{verbatim}
scp ~/Documents/list.txt protocol://user@myhost.com:/home/user/Documents/list.txt
\end{verbatim}

Keep in mind that \texttt{protocol://user@myhost.com} should be changed accordingly to
your use case and may require authentication on the remote server.\\
It's also possible to download files in a similar way.

\begin{verbatim}
scp protocol://user@myhost.com:/home/user/Documents/list.txt ~/Downloads/list.txt
\end{verbatim}

And it can also operate on the remote host only:
\begin{verbatim}
scp protocol://user@myhost.com:/home/user/Documents/list.txt protocol://user@myhost.com:/home/user/Download/shopping.txt
\end{verbatim}


Flags
\begin{itemize}
    \item -1 to use scp with protocol 1 
    \item -2 to use scp with protocol 2 
    \item -3 to copy between 2 remote passing through local(like example above) 
    \item -4 to use scp with IPv4 addresses 
    \item -6 o use scp with Ipv6 addresses 
    \item -C to enable compression of the encrypted connection 
    \item -c to encrypt data transfer (\emph{C} and \emph{c} are \underline{not} the same flag)
\end{itemize}

\section{pass}


\large Claudio Maggioni \normalsize\\




The \texttt{pass} command, also known as \emph{Password Store}, is an
entirely offline password manager that uses \emph{GPG} for encryption with
the ability to sync the (entirely encrypted) passwords using \texttt{git}.
\texttt{pass} works on \emph{MacOS} (avaliable via
\underline{\href{https://brew.sh}{Homebrew}}), \emph{Linux} and on
\emph{Android} (with a GUI app). Think of it as an entirely FLOSS
alternative to services like \emph{Keypass} or \emph{Dashlane}.




Excluding the initial setup (that requires the creation of a \emph{GPG key}),
\texttt{pass} is very easy and straightforward to use: instead of
printing passwords to \emph{stdout}, \texttt{pass} copies them in the
system clipboard, erasing them after a certain number of seconds (usually
\emph{45}).




\texttt{pass} has many unofficial GUI clients and migration scripts from
other password managers. For more information, check out
\underline{\href{https://www.passwordstore.org/\#other}{the official website}}.


Setup



An accurate walkthrough through the setup of \texttt{pass}, in addition
to some other useful sets of commands (such as how to migrate the password
repository to another computer) is provided
in this <a href="https://gist.github.com/flbuddymooreiv/a4f24da7e0c3552942ff">
GitHub Gist by <a href="https://github.com/flbuddymooreiv">
\emph{flbuddymooreiv}.




For more detailed explainations on the setup process or on any commands
please check out the online version of the
\underline{\href{https://git.zx2c4.com/password-store/about/}{man page}}, which is
surprisingly more readable that most of the man pages for other utilities.


Usage



Common \texttt{pass} commands are shown below. For more information refer
to the documentation linked above.



\textbf{
Example: Initialize the password repository with a GPG key with id "0DEADBEEF"
}

\begin{verbatim}
pass init 0DEADBEEF
\end{verbatim}


\textbf{
Example: Insert a password for \emph{example.com} with username \emph{bob} in
  the password repository interactively
}

\begin{verbatim}
pass insert example.com/bob
\end{verbatim}



Please note that the password \emph{name} here follows the most common
naming convention in \texttt{pass}, which is
\texttt{{website}/{username}}. Passwords can be stored in
hierarchical structures (i.e. in nested folders), but the naming is up to the
user.



\textbf{
Example: Generate a password for \emph{zombo.com} of 16 characters and copy it in
the clipboard
}

\begin{verbatim}
pass generate -c zombo.com/bob 16
\end{verbatim}


\textbf{
Example: Retrieve the password for \emph{google.com} and copy it in the system
clipboard (\texttt{-c} flag)
}

\begin{verbatim}
pass -c google.com/bob@gmail.com
\end{verbatim}


\textbf{
Example: Edit the password for \emph{facebook.com} using the default editor
}

\begin{verbatim}
pass edit facebook.com/bob
\end{verbatim}


\textbf{
Edit: Convert the password repository to a git repository for synchronization
}

\begin{verbatim}
pass git init
\end{verbatim}



Every \texttt{git} command on the password repository must be given with
the prefix \texttt{pass git} (e.g. \texttt{pass git push}). An
automatic commit is performed whenever a password is created, edited or
deleted.


\section{fg}


\large Fabiano Fenini \normalsize\\


The \texttt{fg} command allows us to continue a stopped operation by running it
in foreground.\\

The command name stands for \emph{foreground}.\\

Usage

The default fg command syntax is:

\begin{verbatim}
fg [\%job_number]
\end{verbatim}

The parameter \[\%job\_id\] contains the job number you wish to run in foreground.
If this is not indicated, the command will run the last stopped operation.\\

Stop a working job

To stop the execution of a command so that it can be later resumed with \texttt{fg}
you need to press the \texttt{ctrl + Z} keys. The job number to be used with the
\texttt{fg} command will be printed.

\begin{verbatim}
top
\^Z
[1]  + NNNN suspended  top
\end{verbatim}

\section{apropos}


\large Joy Albertini \normalsize\\



The \texttt{apropos} command is used to search command in the shell with a keyword,
it will output all command related to the keyword \\

Example with the command \texttt{apropos archive}, the shell will output tar, zip ecc...\\

\begin{verbatim}
apropos [flags] keyword
\end{verbatim}

Flags

\begin{itemize}
  \item \texttt{-V} (version) print version of the comnmand\\
  \item \texttt{-h} Help message how to use apropos
\end{itemize}

\section{passwd}


\large Fabiano Fenini \normalsize\\


The \texttt{passwd} command allows us to change or to assign a password of authentication
of an user currently in the system.\\
When the user doesn’t have particular privileges, he is only able to change is password,
while the root user has the possibility to change also other users’ passwords.\\
The command name stands for \emph{password}.\\

Usage

The default passwd command syntax is:

\begin{verbatim}
passwd [flags]  [user]
\end{verbatim}

Where \[flags\] are the passwd flags, read below for more info, the parameter \[user\] can only be
specified by the root user. If no user is provided, passwd proceed to set the password of the
user who uses this command. You will first be asked to enter the current user password.\\

Flags

Here are some of the most common passwd flags:

\begin{itemize}
   \item  \textbf{-d}: Delete the user password 
   \item  \textbf{-h}: Get information about how to use this command 
   \item  \textbf{-l}: Lock the password 
   \item  \textbf{-u}: Unlock the password 
   \item  \textbf{-S}: See the account status information 
\end{itemize}

\section{sync}


\large Gianmarco De Vita \normalsize\\




The \texttt{sync} utility force the completion of pending disk writes.

\begin{verbatim}
sync
\end{verbatim}



This command can be used to verify that there are no pending disk writes,
so that all the operations are completed, before the processor is stopped by other
commands.


\section{htop}


\large Joao Tomazoni \normalsize\\



The \texttt{htop} command is used to display the system resources
usage and the active processes.
You can use it to see how your computer is running and what's using the
RAM and the CPU.

\begin{verbatim}
htop
\end{verbatim}

To quit \texttt{htop} you need to type \texttt{q} on your keyboard. You can also click
with the mouse or touchpad to sort the columns of the displayed data.\\
You can move across the stats using the keys on your keyboard.

Flags

\begin{itemize}
    \item \textbf{-d}: set the delay of refresh of information
    \item \textbf{-C}: disable colors
    \item \textbf{-p}: display only a specified process id
    \item \textbf{-u}: display only a specified user
    \item \textbf{-t}: display the processes with a tree view so you can understand better
\end{itemize}

\section{mount}


\large Marco Farace \normalsize\\


To access a file on a Unix-like machine, the file system that contains it
needs to be mounted with the \texttt{mount} command. Mount is frequently used for
movable storage devices such as SD cards, DVDs, etc...\\

The mount command instructs the operating system that a file system is ready to
use, and associates it with a particular point in the overall file system
hierarchy (its mount point) and sets options relating to its access. Mounting
makes file systems, files, directories, devices and special files available for
use and available to the user.\\

Its counterpart, umount, does exactly the opposite.\\
Both mount and umount require root user persmissions.\\
To display all mounted partitions just write \texttt{mount}.\\

This command will mount the second partition of a HDD:\\
\begin{verbatim}
mount /dev/hda2 /media/PHOTOS
\end{verbatim}

and will unmount (by referring to the physical disk partition):\\
\begin{verbatim}
umount /dev/hda2
\end{verbatim}

or (by referring to the mount point):\\
\begin{verbatim}
umount /media/PHOTOS
\end{verbatim}

Flags
\begin{itemize}
    \item -d: Causes everything to be done except for the actual system call.
        This option is useful in conjunction with the -v flag to determine
        what the mount command is trying to do.
    \item -v: Verbose mode. (Gives additional detail during the mount process)
    \item -f: Forces the revocation of write access when trying to downgrade a
        filesystem mount status from read-write to read-only.
    \item -u: The -u flag indicates that the status of an already mounted file
        system should be changed.  Any of the options discussed above
        (the -o option) may be changed; also a file system can be changed
        from read-only to read-write or vice versa.  An attempt to change
        from read-write to read-only will fail if any files on the
        filesystem are currently open for writing unless the -f flag is
        also specified.
      \item -w: Mount the file system read-write.
      \item -o: Options are specified with a -o flag followed by a comma separated
        string of options.  The following options are available:
        \begin{itemize}
            \item noexec: Do not allow execution of any binaries on the mounted file system.
                This option is useful for a server that has file systems containing
                binaries for architectures other than its own.
            \item noowners: Ignore the ownership field for the entire volume. This causes all
                objects to appear as owned by user ID 99 and group ID 99. User ID 99
                is interpreted as the current effective user ID, while group ID 99 is
                used directly and translates to ``unknown''.
            \item nobrowse: This option indicates that the mount point should not be visible via
                the GUI (It will not appear on the Desktop as a separate volume).
        \end{itemize}
    
\end{itemize}

\section{tee}


\large Nicola Brunner \normalsize\\



The \texttt{tee} command is used to split the output of a program, doing
this the output can be displayed in the shell and in the same time written in a
file. This is useful, for example, if we want to capture intermediate outputs of
a long program.
The command is named after the T-splitter used in plumbing, because they have
similar functions.\\

Usage:
The default tee command syntax is:

\begin{verbatim}
tee [flags] [file]
\end{verbatim}

Where \texttt{\[flags\]} are the tee flags (below you will find more info),
and argument \texttt{\[file\]} is a file or a list of files, each of which
receives the output.\\

Flags:

\begin{itemize}
  \item \texttt{-a} Appends the output to each file, rather than overwriting it.
  \item \texttt{-i} Ignores interrupt signals.
\end{itemize}

Example:

\begin{verbatim}
date | tee example.txt
\end{verbatim}

With this example, we can see that tee writes the date in
\emph{example.txt}, but shows also the output (in this case the date) in the shell.
If you would prefer to have content appended instead of overwritten on the file,
should use \texttt{-a} flag on \texttt{tee}.

\section{cat}


\large Fabiano Fenini \normalsize\\


The \texttt{cat} command can be easily associated to the word “concatenation” but
it doesn’t have that only function: in fact, cat command gives us the possibility to create
files and also to display them.\\

The name stands for \emph{catenate}.\\

Usage

The default cat command syntax is:

\begin{verbatim}
cat [flags] [--] [file1] [file2] [file...]
\end{verbatim}

Where \[flags\] are the \texttt{cat} flags, read below for more info, \[--\] indacates that the
following parameters won't be considered as flags, while the file parameters indicates
the names of one or more files to concatenate.
Between the names of two files is possible to use the shell redirection symbol "\textgreater ",
in order to redirect the output to the file considered.\\

Flags
Here are some of the most common cat flags:

\begin{itemize}
   \item  \textbf{-n}: Display the line numbers of a file 
   \item  \textbf{-e}: Display "\$" at the end of the line and also where there is a gap between paragraphs 
   \item  \textbf{-T}: Display TAB characters 
\end{itemize}

\section{neofetch}


\large Marco Farace \normalsize\\





Neofetch is a fast, higly customizable system info script. a  CLI  system
information tool written in BASH. Neofetch displays information about your
system next to an image, your OS  logo, or any ASCII file of your choice.

Flags
\begin{itemize}
    \item --disable \[infoname\]: Allows you to disable an info line from appearing
        in the output. infoname' is the function name from the 'print\_info()'
        functioninside  the  config  file.For example: 'info "Memory" memory'
        would be '--disable memory'.
    
    \item --colors \[x x x x x x\]: Changes the text colors in this order:
        \texttt{title, @, underline, sub-title, colon, info}
    
    \item --underline \[on/off\]: Enable/Disable the underline.
    \item --bold \[on/off\]: Enable/Disable bold text
    \item --backend \[backend\]: Which image backend to use. Possible values:
        \texttt{'ascii', 'caca', 'jp2a', 'iterm2', 'off', 'sixel', 'tycat', 'w3m'}
    
    \item --source \[source\]: Which image or ascii file  to  use. Possible values:
        \texttt{'auto', 'ascii',    'wallpaper',    '/path/to/img', '/path/to/ascii',
            '/path/to/dir/'}
    
    \item --ascii \[source\]: Shortcut to use 'ascii' backend.
\end{itemize}

\section{kill}


\large Announ Marwan \normalsize\\


The \texttt{kill} command is used for terminating the
running processes on your system.\\

In fact, using this commands you can easily kill all the processes that you want.
Sometimes happens that you couldn't control an application, for example when
you want to exit from your browser when it seems freezing.
You have to know that "kill commands" can help you in do this.\\

killall

Will terminate all programs that match the name specified without
additional arguments.
You have to know also that "killall" sends SIGTERM, or signal number 15.
If you want to specify a different signal you can use "-s".

\begin{verbatim}
killall -s 9 [process name]
killall -KILL [process name]
killall -9 [process name]
\end{verbatim}

kill

Will terminate only one program.
Without options, kill sends SIGTERM to the PID specified and asks the application
or service to shut itself down.

\begin{verbatim}
kill [PID]
kill -s KILL [PID]
kill -KILL [PID]
\end{verbatim}

\section{curl}


\large Claudio Maggioni \normalsize\\


The \texttt{curl} command is a fast and versatile shell program that can
request online content using various protocols, including \emph{HTTP},
\emph{FTP} and \emph{POP3}. Some example use cases for this utility are
the need to automate some remote call to a server, testing \emph{REST} or
\emph{SOAP} apis or simply download or display the \emph{HTML} code of a
website.

The name, as mentioned in the <a href="https://ec.haxx.se/curl-name.html">
\emph{Evertything curl} online book, stands for \emph{"client URL"}
and the right pronunciation rhymes with "earl" or "girl". By this fact, the
reader is able to tell the author of this page to stop pronuncing it as
\emph{"cooorl"}, like if the name is some sort of word in the
<a href="https://en.wikipedia.org/wiki/Bergamasque\_dialect">\emph{Bergamasque
dialect}.

Usage

\texttt{curl} is a very complex command: if you want to learn it deeply,
please refer to the previously mentioned guide called
\underline{\href{https://ec.haxx.se/}{\emph{Evertything curl}}}. Some basic
ways to use this command are shown below:

Example: Download the contents of the page "example.com" to "file.html"

\begin{verbatim}
curl example.com -o file.html
\end{verbatim}

Example: Download the contents of the page "en.wikipedia.org/wiki/Curl" to
a file with the same name as the last element in the path (here "Curl")

\begin{verbatim}
curl -O en.wikipedia.org/wiki/Curl
\end{verbatim}

Example: Download the contents of the page "example.com" to "file.html"

\begin{verbatim}
curl example.com -o file.html
\end{verbatim}

Example: Download the contents of the page "example.com" following location
redirects (\texttt{-L} flag)

\begin{verbatim}
curl -O -L example.com
\end{verbatim}

Example: Download the contents of the page "example.com" resuming a previous attempt
(\texttt{-C} flag)

\begin{verbatim}
curl -O -C example.com
\end{verbatim}


Example: Do an HTTP DELETE request to "example.com" with a custom header
(\texttt{-H} and \texttt{-X} flags)

\begin{verbatim}
curl -H 'User-Agent: Tamagotchi' -X DELETE example.com
\end{verbatim}

Example: Print to \emph{stdout} "example.com" making a request with HTTP basic
authentication (\texttt{-u} flag)

\begin{verbatim}
curl -u bob:P@ssw0rd example.com
\end{verbatim}

\section{ps}


\large Andrea Brites Marto \normalsize\\





The \emph{ps} command stands for "process status" and it is used to provide
various information about the currently running processes.\\

Every process is an executing instance of a program which is assigned a unique PID
(process identification numbers) by the system.

The basic syntax of \emph{ps} is:

\begin{verbatim}
ps [options]
\end{verbatim}



This command can be used without any option and by doing this you will get the standard output,
which is the display monitor by default with four items of information for at least two
processes currently on the system: the shell and ps.\\

Since we have already saw PID before, the TTY information that stands for terminal type
(originally teletype) is the console (or terminal) in which the user logged into.\\

TIME is very simple: is the amount of CPU time in minutes and seconds that the process
has been running. CMD is simply the name of the command that launched the process.\\

Here you will find some common option combinations


\begin{verbatim}
ps aux | less
\end{verbatim}

\begin{itemize}
    \item The -a option is used to list the processes of all users on the system.
    \item The -u option tells ps to provide detailed information about each process.
    \item The -x option adds to the list, processes that have no controlling terminal
        (programs launched during booting).
    
\end{itemize}



This can be piped to the less command (see our section pipe), which let us to
view all processes in one screenfull at a time.\\

Another way to view all processes running on the system is:


\begin{verbatim}
ps ef | less
\end{verbatim}

Where:

\begin{itemize}
    \item The -e option is used to generate a list of information about every process
        (currently running).
     
    \item The -f option provides a list that contains some information for each process.
\end{itemize}



This is very useful, it can be used for example to control UID information (username of
the account that owns the process) and STIME to know when the process started, or
the starting date.\\


In the end the \emph{ps} is very powerful if we know how to use it.
If you need to kill a process you can list all process in various ways
and search for the process you need to kill by reading its PID or by UID for example.


\section{ssh}


\large Announ Marwan \normalsize\\



The \texttt{ssh} command is used to operate with a remote machine using
the \emph{ssh} protocol. It's commonly used for logging into a remote
machine and execute commands from a terminal interface.


Log into a server

To log in a remote server you need an user account which is
usually created by the server admin and a password.

\begin{verbatim}
localhost:[~]\textgreater  ssh username@remote-server
remote-server:[~]\textgreater 
\end{verbatim}

Once you're logged in, the local machine shell will be
\emph{replaced} by the remote server's one.\\

Log out of a server

\begin{itemize}
    \item Press \texttt{⌘ + D}
    \item Run the command \texttt{logout}
    \item Run the command \texttt{exit}
\end{itemize}

Run a command on a remote machine

\begin{verbatim}
localhost:[~]:\textgreater  ssh user@remote-host "ls test"
    online-backup.dat
    online-storage
    unix-dedicated-server.txt
\end{verbatim}


Debug the client

Debugging the ssh client can be useful to resolve connection errors.

\begin{verbatim}
localhost:[~]:\textgreater  ssh -v user@remote-host
    OpenSSH_4.3p2, OpenSSL 0.9.8e-fips-rhel5 01 Jul 2008
    debug1: Reading configuration data /etc/ssh/ssh_config
    debug1: Applying options for *
    debug1: Connecting to remote-host [172.22.200.140] port 22.
    debug1: Connection established.
    debug1: identity file /home/user/.ssh/identity type -1
    debug1: identity file /home/user/.ssh/id_rsa type -1
    debug1: identity file /home/user/.ssh/id_dsa type 2
    debug1: loaded 3 keys
    ...
\end{verbatim}

\section{who}


\large Marco Farace \normalsize\\


The \texttt{who} command displays a list of all logged in users/display info
about current user

The who utility displays a list of all users currently logged on, showing
for each user the login name, tty name, the date and time of login, and
hostname if not local.\\

Flags
Here are just some of the most useful options for this command:

\begin{itemize}
    \item -b: Display time of last system boot.
    \item  -d: Print dead processes.
    \item -H: Write column headings above the regular output.
    \item -m: Only print information about the current terminal.
    \item -q: \emph{Quick mode}: List only the names and the number of users currently logged on.
        When this option is used, all other options are
        ignored.
    
    \item -s: List only the name, line and time fields. This is the default.
    \item -T: Print a character after the user name indicating the state of the
        terminal line: "+" if the terminal is writable; "-" if it is not;
        and "?" if a bad line is encountered.
    
    \item -u: Print the idle time for each user, and the associated process ID.
    \item am I: Returns the invoker's real user name. You can also use \texttt{whoami}
    \item file: By default, who gathers information from the file /var/run/utmpx.
        An alternative file may be specified.
    
\end{itemize}

\section{Closing the shell}


\large Marzio Lunghi \normalsize\\


If you want to close the shell session, there are several ways to do so:

\begin{itemize}
    \item Press \texttt{\^ (control) + D}. Although this key combination closes the shell,
        it doesn't quit the terminal application as it just saves and closes the current session.
        A closed session does not allow any input or output anymore.
    
    \item Insert the \texttt{exit} command. Unlike the mentioned key combo, exit also quits
        the terminal application itself.
    
\end{itemize}

\section{open}


\large Gianmarco De Vita \normalsize\\



You can open files and folder as new windows through the terminal.
The command is \texttt{open}. By writing the command open followed by the
path and the name of the file (remember that you can omit the path if
the file is in the current position), a new window in the common user
interface opens. Now you can work on the opened file.

\begin{verbatim}
open path/name-file
\end{verbatim}

Open a file with a specific application
Adding the flag \texttt{-a} to the command permit you to decide with
which specific application open the file. Just write the flag followed by the
name of the application.

\begin{verbatim}
open -a application-name path/name-file
\end{verbatim}

Assume that you want to open the file \emph{abc.pdf} on my Desktop using the program "preview".

\begin{verbatim}
open -a preview Desktop/abc.pdf
\end{verbatim}

As result, a new \emph{Preview} window appears showing the content of the
chosen file.\\

Open the folder which contains the file
If you want to open the folder that contains a specific file, just use
the flag \texttt{-R} and write the path and the name of the file you want to open.

\begin{verbatim}
open -R Desktop/text.txt
\end{verbatim}

As result, a new \emph{Finder} window opens the folder displaying its content.\\

Open a file with an editor
If you want to open a file with your default editor,
just use the flag \texttt{-t} and write the path and the name of
the file you want to open.

\begin{verbatim}
open -t Desktop/text.txt
\end{verbatim}

Visit a Website
You can use this tool not only to open files and folders, but also webpages.
Just write the command \texttt{open} followed by the \emph{URL} of the page
you want to visit.

\begin{verbatim}
open http://www.google.com
\end{verbatim}

A new page of your default browser will open on the indicated page (in this
example, the main page of the Google Search Engine).

\section{man}


\large Gianmarco De Vita \normalsize\\




The \texttt{man} tool allows you to explore the various utilities
of the Shell. To search for more information about a command, just write

\begin{verbatim}
man command-name
\end{verbatim}



As result, a new session will be opened with information about the command
you have typed (and more specifically about its functions and flags).\\

Using some flags, you can obtain with this command the same results you get
when you use other commands.


Flags

\begin{itemize}
    \item  \textbf{-k}: returns the equivalent of \texttt{apropos}
    \item  \textbf{-f}: returns the equivalent of \texttt{whatis}
\end{itemize}

\section{mv}


\large Joy Albertini \normalsize\\




The \texttt{mv}  move a file from a directory to another:
  Device-name:Current-position username\$ mv path/name-file path2
You can verify the success of the operation by using the command ls with argument the path. \\
With mv you can rename a file: Device-name:Current-position username\$ mv path/name-file mv path/newname-file


\begin{verbatim}
  mv /home/user/desktop/file.txt /home/user/desktop/subfolder1/
\end{verbatim}

\begin{itemize}
  \item \texttt{-i} Prompt(request confirm) before overwriting the file (Overrides previous -f or -n options, and override file permission) \\
  Example: mv -i name1.txt name2.txt, shell will ask overwrite 'name2.txt'? respond with Y(yes) or N(no)
  \item \texttt{-n} Don't permit to overwrite existing file \\
  Example: desktop as working directory there is a file called name2.txt, mv -n name5.txt name2.tx, with the flag -n you can't overwrite the file. 
  \item \texttt{-v} (verbose) will output information explaining what it's doing \\
  Example: mv-v name1.txt name2.txt, the shell will output the operation: 'name1.txt' -to 'name2.txt'. 
  \item \texttt{-f} (Force) force overwriting without prompting (overrides previous -i or -n options).\\
  Example: desktop as working directory there is a file called name2.txt, mv-f name1.txt name2.txt will overwrite the file without prompting
\end{itemize}

\section{MacOS terminal toolbar}


\large Marzio Lunghi \normalsize\\



Once the MacOS Terminal app has been opened, a menu bar will appear exactly in the upper
left corner of the screen. This menu contains some preferences that could improve the user
experience and use of the Terminal.\\
The menu is divided into 6 sections that I will describe briefly to give you a basic knowledge
that could be very useful once you have become familiar with the program.

Terminal



\begin{itemize}
    \item \textbf{Secure Keyboard Entry}:
        Inside the Terminal section you will find the item “secure Keyboard Entry”, this tool
        allows the user to enable an additional system security.\\
        Essentially, this option prevents other Application from seeing what you are
        typing on the shell.\\
        It also prevents processes that are working in background from
        monitoring your keystrokes.\\
        In a first moment it seems that it doesn’t do anything, that’s because for
        people who works on their own personal computer, this additional secure may
        become an unnecessary precaution.\\
        However, this option could be very useful if you using an unknown computer
        or a public computer.
    
    \item \textbf{Hide terminal}:
        Although Shell’s window does not take a lot of space, it is possible to hide
        the window by pressing \texttt{⌘ + H}.
    
    \item \textbf{Hide Others}:
        In the other hand, it’s possible to hide all the others windows (except the Terminal) by
        pressing  \texttt{⌥ + ⌘ + H}.
    
    \item \textbf{Quit Terminal}:
        Once you have finished working with the Terminal, you can definitely close it by
        pressing  \texttt{⌘ + Q}.
    
\end{itemize}

Shell



\begin{itemize}
    \item \textbf{New Window}: It creates a new window.
    \item \textbf{New Tab}: It creates a new tab
    \item \textbf{Close window}: This option closes the window without quitting the terminal.
    \item \textbf{Show Inspector}:
        This option allows the user to customise the layout of the shell.
        This option contains some profiles that you can use instead of spending
        time to create your own one.\\
        This option is not permanent, once the terminal has been quitted, the shell is set
        with the default settings.
    

    \item \textbf{Edit Title}:
        This options shows the inspector too, but it selects the current title that
        you want to change
    
    \item \textbf{Edit Background Colour}:
        This options shows some useful tools to customise the background of the shell.
    
    \item \textbf{Reset}: This option re-initializes the terminal.
    \item \textbf{Hard Reset}: This option re-initialize completely the terminal.
    \item \textbf{Print Selection}:
        This option allows the user to print only a selection of the shell.
        The text must be selected by holding down the touchpad and then moving the mouse cursor.
    
    \item \textbf{Print}: This options prints all the content of the shell.
\end{itemize}

Edit



\begin{itemize}
    \item \textbf{Undo}: Undo the last input action.
    \item \textbf{Redo}: Redo the last undone input action.
    \item \textbf{Cut}:
        Traditionally, the cut command was designed to move texts within applications, but,
        according to the Mac user community, it’s not very intuitive.\\
        There is a much easier alternative way, the copy and paste,
        known as \texttt{⌘ + C} (copy) and \texttt{⌘ + V} (paste).
    \item \textbf{Copy}: Copy the selected text.
    \item \textbf{Copy Special}:
        It copy a selected text by giving you more options.
        For example, if you have a black background, copy special allows you to copy a
        selected file without considering the colour of the background
    
    \item \textbf{Paste}: Past the text from the system clipboard.
    \item \textbf{Paste Escaped Text}:
        If you want to copy a text with special symbols, precisely code text,
        you have to use paste escaped text to maintain the text intact and not have characters
        interpreted as code.
    
    \item \textbf{Select All}: It selects all the content of the shell.
    \item \textbf{Select Between Marks}: It selects a portion of the text between marks.
    \item \textbf{Clear to Previous Mark}: Delete the last command and its contents.
    \item \textbf{Clear to Start}: Delete all the content up to the start.
    \item \textbf{Clear Scrollback}: It deletes all the not visible content.
    \item \textbf{Clear Screen}: It deletes all the visible content on the screen.
    \item \textbf{Find}:
        It allows the user to find portions of text or words that matches with the inserted one.
    
\end{itemize}

View



 \begin{itemize}
    \item \textbf{Show All Tabs}:
        It shows all tabs that you created, if no one has been created it will
        show only the current one.
    
    \item \textbf{Show Tab Bar}:
        It shows you a tab bar with all the tabs created, this option is
        automatically enabled when you select “New Tab” under Shell section.
    
    \item \textbf{Show Alternate Screen}: It creates an alternate screen.
    \item \textbf{Hide Alternate Screen}: Disable the option “Show Alternate Screen”.
    \item \textbf{Allow Mouse Reporting}:
        It means that mouse clicks will be visible to whatever is reading the terminal,
        the position and click will be encoded and used by Text mode mouse-aware
        applications with standards permissions
    
    \item \textbf{Split Panel}: It split every window in two windows
    \item \textbf{Close Split panel}: It closes all the windows created with the "Split panel"
    \item \textbf{Default Font Size}:
        It set up default font size, if the size has been increased or decreased.
    
    \item \textbf{Bigger}: It makes the font bigger.
    \item \textbf{Smaller}: It makes the font smaller.
    \item \textbf{Scroll to Top}: Scroll to the top, at the start.
    \item \textbf{Scroll to Bottom}: Scroll to the bottom, at the end.
    \item \textbf{Page Up}: It scroll up to the previous page.
    \item \textbf{Page Down}: It scroll down to the next page.
    \item \textbf{Line Up}: It scroll up to one line.
    \item \textbf{Line Down}: It scroll down to one line.
    \item \textbf{Enter Full Screen}: It makes the window fulls screen.
\end{itemize}

Window



\begin{itemize}
    \item \textbf{Minimise}: It reduces the terminal to an icon.
    \item \textbf{Zoom}:
        It increases the size of the window.
        By default the size is set up to 80 x 24.
    
    \item \textbf{Cycle Trough Windows}: It switches between open windows
    \item \textbf{Show Previous Tab}: It shows previous tab, if any
    \item \textbf{Show Next Tab}: It shows next tab, if any.
    \item \textbf{Move Tab to New Window}: It moves a tab to a new window.
    \item \textbf{Merge All Windows}: It takes all the windows and moves them to Tabs.
    \item \textbf{Return to Default Size}: It returns to default size of the window (80 x 24).
\end{itemize}

Help



\begin{itemize}
    \item \textbf{Terminal Help}:
        It opens a useful guide that show you how familiarize with Terminal.
    
    \item \textbf{Open man Page for selection}:
        Instead of digit man on the shell you can simply select the command and click on this option.
        It will give you back an external manual page with all the descriptions
    
\end{itemize}

\section{Open the Shell}


\large Gianmarco De Vita \normalsize\\



The tool that allows us to interact with the system with the shell is the terminal.
There are mainly two ways to access to the terminal on a MacOS system.

Through the Finder



\begin{itemize}
  \item Open a new \emph{Finder} window by clicking on the icon on the system dock.
  \item On the menu bar, click on \emph{Go}.
  \item Click on \emph{Utilities}.
  \item Look for \emph{Terminal} and click on it.
\end{itemize}



Through \emph{Spotlight}
\begin{itemize}
  \item You can use the shortcut \texttt{cmd+space} to access to \emph{Spotlight}.
  \item Then search for \emph{Terminal}.
  \item Click on the \emph{Terminal} icon displayed as result.
\end{itemize}



The terminal

As you open the Terminal, a new blank window opens:\\
You can notice that the top lines in the window follow this structure:

\begin{verbatim}
Last login: Day Month hh:mm:ss on console
Device-name:~ username$
\end{verbatim}

The tilde (~) just before your username means that the current position in
which the terminal is working is the Home directory. The gray spot next to
the symbol \$ after your username indicates that you can write instructions
in that space.\\

Now, you are ready to try and use some simple commands
to familiarize with this interface.\\

Note that you can work simultaneously on multiple sessions of the Terminal.

\section{chown}


\large Joy Albertini \normalsize\\




The \texttt{chown}
If you want to change the user ID of a specific file, you can use chown. \\
Device-name:Current-position username\$ chown owner\[:group\] file \\
Example chown Joy:student alice.txt add Joy to the group student \\
Use chgrp \[:group\] file to create a group for a file \\
Use Sudo chown owner\[:group\], if you need root permission for add the user to the group 

\begin{verbatim}
chown user [group] file1 file2 ...
\end{verbatim}

\begin{itemize}
    \item \textbf{-f} Don't show all error messages except usage messages.
    \item \textbf{-h} Changes the symbolic link and not the file or directory referred
        by the symbolic link.
    
    \item \textbf{-R} changing the ownership for each file in a folder, if it encounters
        a symbolic link it will cheange the owenership of that symbolic link,
        and the directoryfile referred in the symbolic link, but the directory is not
        further transversed.
    
  \item \textbf{-RH} changing the ownership for each file in a folder, if encounter symbolic link
        it will change the owenership of that symbolic link,
        the directory/file referred in the symbolic link, and all the
        directory is further transversed.
    
  \item \textbf{-RL} If the -R option is specified and a symbolic link referencing a file of type directory
        is specified on the command line or encountered during the traversal of a file hierarchy,
        the chown command shall change the user ID (and group ID, if specified) of the directory
        referenced by the symbolic link and all files in the file hierarchy below it.
    
    \item \textbf{-RP} changing the ownership for each file in a folder, if encounter symbolic
        link it will cheange the owenership of that symbolic link, but will not chenage the
        the directory/file referred in the symbolic link, and  the directory is not
        further transversed.
    
\end{itemize}

\section{more and less}


\large Marzio Lunghi \normalsize\\




Both commands show the content of one or more files and it’s possible to do a research with
particular flags, but the “less” one allows us to go also backwards while reading the text
of a file.\\
More is quite old, less is more recent and powerful.\\

General syntax for both is:


\begin{verbatim}
less [flags] path/name-file.*
more [flags] path/name-file.*
\end{verbatim}



The command \texttt{less} provides some useful commands to navigate and modify the file content.
Commands does not include flags, which are included under \emph{Options}.


Commands



Such commands must be used once the file has been displayed.
They are not flags. For a single operation there can be multiple commands.


\begin{itemize}
    \item \texttt{ENTER  RETURN e  \^E  j  \^N  CR }:
        Scroll forward N lines, 1 by default, if N is not specified.
    \item \texttt{ y  \^Y  k  \^K  \^P }:
        Scroll backward N lines , 1 by default , if N is not specified.
    \item \texttt{ f  \^F  \^V  SPACE }:
        Scroll forward  N lines, a window by default, if N is not specified.
    \item \texttt{ b  \^B  ESC-v }
        Scroll backward N lines, one window by default, if N is not specified.
    \item \texttt{ ESC-SPACE }
        Scroll forward  one window like SPACE , but don't stop at end-of-file.
    \item \texttt{d  \^D }
        Scroll forward  N lines, by default N correspond to half of the screen size.
    \item \texttt{ u  \^U }
        Scroll Backward  N lines, by default N correspond to half of the screen size.
    \item \texttt{ ESC-)  RightArrow }
        Scroll horizontally right  N characters, by default half of the screen size, if N is not specified.
    \item \texttt{ ESC-(  LeftArrow }
        Scroll horizontally left  N characters, by default half of the screen size, if N is not specified. 
\end{itemize}

Jumping



Such commands must be used once the file has been displayed.
They are not. For a single operation there can be multiple commands. 

\begin{itemize}
    \item \texttt{  g  \textless   ESC-\textless    }:
        Go to line N, by default 1, if N is not specified.
    \item \texttt{ G  \textgreater   ESC-\textgreater  }:
        Go to line N, by default the last one , if N is not specified.
    \item \texttt{  t }:
        Go to the (N-th) next tag. 
    \item \texttt{ T }
        Go to the (N-th) previous tag.
\end{itemize}

Flags

Options may be given in one of two forms: either a single
character preceded by a "-", or a name preceded by "--" .

\begin{itemize}
  \item \texttt{ ?    OR    --help }
    Display help guide with the description of commands and more , it is sufficient to enter less -? .
  \item \texttt{ -c  OR   --clear-screen }
    Repaint by clearing rather than scrolling.
  \item \texttt{ -e  -E  OR  --quit-at-eof  --QUIT-AT-EOF }
    Quit the file, when you scroll to the end of the file.
  \item \texttt{  -~  OR  --tilde }
    Do not display tildes after end of file. 
\end{itemize}

\section{ls}


\large Alessandro Marinelli \normalsize\\


The \texttt{ls} command is used to list a directory content or a file.\\
The name stands for \emph{LiSt}.

The default ls command syntax is:

\begin{verbatim}
ls [flags] [path]
\end{verbatim}

Where \[flags\] are the ls flags, read below for more info,and \[path\] is the
(optional) path (absolute or relative).If no path is provided the current
directory is listed.\\

Usage

List the elements on the current working directory
Let's see how to show a list containing the elements included in the
current working directory

\begin{verbatim}
ls
    Other Multimedia	my-cat.jpg
    Photos				Videos
\end{verbatim}

As you can see, typing \texttt{ls} in the Unix Shell, will give as output
the list of elements contained in the current working directory.\\
Elements listed can be files (look for exemple at the element\emph{my-cat.jpg}),
such as other directories (look for example at the folder \emph{Photos}).\\

List the elements contained in a directory
\begin{verbatim}
ls Photos
    01.jpg		02.jpg
    03.jpg		04.jpg
\end{verbatim}

As you can see, now the Unix Shell is showing us the elements contained
in the folder \emph{Photos}.\\

Show hidden files
You can include hidden files (those  which name starts with ".") in
the displayed list using the \texttt{-a} flag.

\begin{verbatim}
ls -a Photos
    .				01.png
    ..				02.png
    .DS_Store		03.png
    .secret.png		04.jpg
\end{verbatim}

As you can see, now the shell shows more files for the same directory.\\

Show list in long format

\begin{verbatim}
ls -l
    total 10816
    -rw-r--r--@ 1 YourName  YourGroup  3143706  4 Ott 13:28 01.png
    -rw-r--r--@ 1 YourName  YourGroup  2269193 28 Ott 18:58 02.png
    -rw-r--r--@ 1 YourName  YourGroup  37900   28 Ott 22:07 03.png
    -rw-r--r--@ 1 YourName  YourGroup  75924   20 Ott 16:01 04.jpg
\end{verbatim}

If the \texttt{-l} flag is given, the following information will be displayed for
each file: file mode, number of links, owner name, group name, number of
bytes in the file, abbreviated month, day-of-month file was last modified,
hour file last modified, minute file last modified, and the path.

In addition, for each directory whose contents are displayed, the
total number of 512-byte blocks used by the files in the directory is
displayed on a line by itself, immediately before the information for the
files in the directory.

\section{whatis}


\large Marzio Lunghi \normalsize\\



The \texttt{whatis} command gives you a brief description of a command.

\begin{verbatim}
whatis command
\end{verbatim}

It's similar to \texttt{man -f command}

\section{clear}


\large Marzio Lunghi \normalsize\\


If you want to clear the shell screen up to the start you have to digit
the \texttt{clear} command:

\begin{verbatim}
clear
\end{verbatim}

This command corresponds to the \texttt{ ⌘ + K } key combination on Mac OS

\section{info}


\large Gianmarco De Vita \normalsize\\


An \emph{.info} file is an information document created by Texinfo.\\
It stores documentation in a book format with chapters, sections,
and subsections and can contain up to four layers of depth.\\
Info documents are used for storing software help manuals and technical books.\\
The \texttt{info} command allows you to read that kind of files
and to search for particular information by using special flags.

\begin{verbatim}
info [flag] [item]
\end{verbatim}

Look up for a specific string

Using the \texttt{--apropos} flag followed by a string, you obtain as
output a list of all the contents which correspond to the string you wrote.

\begin{verbatim}
info --apropos string
\end{verbatim}

If the string you inserted has nothing to do with the content of the info files,
you will get a error message. For example:

\begin{verbatim}
info --apropos duck
    info: No available info files have `duck' in their indices.
\end{verbatim}

An help with this command
Using the \texttt{-h} flag (which stands for help), you obtain as
output a brief paragraph in which are explained the features of this command.\\

Visit a specific \emph{.info} file

Using the \texttt{-f} flag followed by the path and a \emph{.info} file, you
as output obtain the content of that file.

\begin{verbatim}
info -f path/filename.info
\end{verbatim}

\section{say}


\large Gianmarco De Vita \normalsize\\



You can convert text into audible speech just by writing the command
\texttt{say} followed by a string.
This is possible thanks to the \emph{Speech Synthesis manager} on Mac OS.

\begin{verbatim}
say string
\end{verbatim}

Naturally, the wide presence of flags for this command allows you to use
this command for many different tasks. Notice that using more flag
simultaneously, you will be able to solve more complex operations.\\

Read a particular file
By writing the command followed by the flag \texttt{-f} and, instead
of the string, by the path of a text file, you will get as output a voice
reading the content of that file.

\begin{verbatim}
say -f path/text.txt
\end{verbatim}

Specify the reading voice
By writing the flag \texttt{-v} followed by a person name and a string, you
can decide which voice should read the string.

\begin{verbatim}
say -v name string
\end{verbatim}

Of course, you're not expected to know every possible voice,
so, by writing a string (eg: "Hello world") as argument of the command
(including also the flag -v), you will get a list of all the available voices.

\begin{verbatim}
say -v "Hello world"
\end{verbatim}

Specify the Speech Rate
By writing the flag \texttt{-r} followed by a rate and then by a
string, you can decide the reading speed in words per minute.

\begin{verbatim}
ay -r rate string
\end{verbatim}

Store the output in an audible file
You can save the result of the command in an audible file. To do that,
you have just to write after the command the flag \texttt{-o} followed
by the path/name of the output file and then the string that has to be read.

\begin{verbatim}
say -o path/audiofile.*format string
\end{verbatim}

As said above, you can use more flags in the same command, once you know
well them. See the examples below and try to guess the output. You can
copy these commands into your terminal to verify your answers. Naturally,
you have to create the text files if they don't exist (with some text
inside), to make the work.

\begin{verbatim}
say -v Alex -f hello_world.txt
\end{verbatim}

\begin{verbatim}
say -o hi.aac -f hello_world.txt
\end{verbatim}

\section{ln}


\large Riccardo Antonio Vivanco \normalsize\\



The \texttt{ln} command is used to create a link of a file or directory.
A link is used to create multiple copies of a file in
different places without using more storage than that needed to store a single copy
of the given file.\\
The copies are instead a link that points to the original file. If the original is deleted,
the copies will point to a non-existant file and become pointless.\\
The name of the command stands for \emph{LiNk}\\

There are 2 kinds of links: \textbf{hard} and \textbf{symbolic}.\\

In an hard link, the original is indistinguishable from the linked copy, and the changes
made to the file are the same, regardless of whether the modified file is the
original or the linked copy. Hard links are not used for directories.
\texttt{ln} creates hard links by default\\

The symbolic link (symlink) instead contains the path to the original file and referencing the linked copy
will make the referencer point to the original file instead.\\

\begin{verbatim}
ln [flags] [source1] [source2] ... [target_dir]
ln [flags] [source] [target]
link [source] [target]
\end{verbatim}

The \texttt{link} command can be used instead of \texttt{ln}, but flags and multiple
source files won't be supported.\\

If multiple sources are supplied, the last parameter of the command must be a directory inside
which the links will be created.

Flags

\begin{itemize}
    \item \textbf{-F}: overwrites the \[target\] file / directory if it already exists.
    \item \textbf{-h}: if the \[source\] is a symlink, do not follow it
    \item \textbf{-f}: if the \[target\] already exists, unlink it before replacing it.
    \item \textbf{-i}: ask for confirmation in case the \[target\] file already exists.
    \item \textbf{-s}: creates a symbolic instead of hard link
\end{itemize}

\section{du}


\large Joey Bevilacqua \normalsize\\



The \texttt{du} command is used to display files and directories sizes.\\
The name stands for \emph{Disk Usage}.

\begin{verbatim}
du [flags] [file1] [file2] [directory1] ...
\end{verbatim}

Flags

\begin{itemize}
    \item \textbf{-a}: shows the size of each individual file inside a given folder,
        not the folder total size.
    
    \item \textbf{-c}: shows the total size of all the files passed as arguments
    \item \textbf{-d}: select the max depth of folder recursion
    \item \textbf{-h}: shows the sizes in an human-readable format
    \item \textbf{-g}: shows the sizes with GB units
    \item \textbf{-m}: shows the sizes with MB units
    \item \textbf{-k}: shows the sizes with KB units
\end{itemize}

\section{pwd}


\large Mirko Ponzio \normalsize\\





The command \texttt{pwd}(abbreviation of print working directory, it returns the
corrent directory) it is a command, that show the absolute pathname on the corrent directory.\\

The working directory is the directory where you are standing in. So for
knowing where you are, you can use the pwd command.\\

\begin{verbatim}
cd /home/user
pwd = /home/user
\end{verbatim}

Flags

\begin{itemize}
    \item \texttt{-P } Show the  working directory path without symbolic link (links to
        folder).\\
        Example: \emph{/home/symphoto} a symlink to \emph{/home/photos} \texttt{pwd -P}
        will display \emph{/home/photos}.
    
    \item \texttt{-L } Show the working directory logical path with symbolic link.\\
        Example: \emph{/home/symphoto}, that redirect to \emph{/home/photos},
        \texttt{pwd -L} will show \emph{/home/symphoto}.
    
    \item Without any flag, -L is assumed, so the normal pwd is in reality \texttt{pwd -L}.
\end{itemize}

\section{mv}


\large Mattia Hijman \normalsize\\





The \texttt{mv} command is used to move a file from a given path to another.
It can also be used to rename a file by moving it into the same directory,
but with a different name.\\
It stands for \emph{MoVe}.

\begin{verbatim}
mv [-finv] source target
\end{verbatim}

Flags

\begin{itemize}
    \item  \textbf{-f}: Force overwriting  file(s) without asking a confirmation.
    \item  \textbf{-i}: Request confirmation before overwriting the file(s).
    \item  \textbf{-n}: Don't allow to overwrite existing file(s).
    \item  \textbf{-v}: Cause mv to be verbose, showing files after they are moved.
\end{itemize}

\section{ls}


\large Mirko Ponzio \normalsize\\


The command \texttt{ls} stands for "LiSt"\\

In computing, ls is a command to list computer files in Unix and Unix-like operating systems.
ls is specified by POSIX and the Single UNIX Specification.\\
When invoked without any arguments, ls lists the files in the current working directory.\\
The command is also available in the EFI shell. In other environments, such as DOS and Microsoft
Windows, similar functionality is provided by the dir command.\\

Unix and Unix-like operating systems maintain the idea of a current working directory,
that is, where one is currently positioned in the hierarchy of directories.\\
When invoked without any arguments, ls lists the files in the current working directory.
If another directory is specified, then ls will list the files there, and in fact the user may
specify any list of files and directories to be listed.\\

Files whose names start with "." are not listed, unless the -a flag is specified,
the -A flag is specified, or the files are specified explicitly.\\

Without options, ls displays files in a bare format. This bare format however makes
it difficult to establish the type, permissions, and size of the files.\\

Flags

The most common options to reveal this information or change the list of files are:
\begin{itemize}
    \item -l long format, displaying Unix file types, permissions, number of hard links,
        owner, group, size, last-modified date and filename.
    
    \item -f do not short. Useful for directories containing large numbers of files.
    \item -F appends a character revealing the nature of a file, for example, * for an executable,
        or / for a directory. Regular files have no suffix.
    
    \item -a lists all files in the given directory, including those whose names start with "."
        (which are hidden files in Unix). By default, these files are excluded from the list.
    
    \item -R recursively lists subdirectories. The command ls -R / would therefore list all files. 
    \item -d shows information about a symbolic link or directory, rather than about the link's
        target or listing the contents of a directory.
    
    \item -t sort the list of files by modification time.
    \item -h print sizes in human readable format. (e.g., 1K, 234M, 2G, etc.).
  
\end{itemize}

\section{rm}


\large Mattia Hijman \normalsize\\



The \texttt{rm} command is used to delete and unlink directories and files.\\
It attempts to remove the non-directory type files specified on the command line.
If the permissions of the file do not permit writing, the user is prompted for confirmation.\\
It stands for \emph{ReMove}.

\begin{verbatim}
rm [-dfiPRrvW] file1 file2 file....
\end{verbatim}

Flags
\begin{itemize}
    \item  \textbf{-d}: Attempt to remove directories as well as other types of files
    \item  \textbf{-f}: Attempt to remove the files without prompting for confirmation, regardless
        of the file's permissions. If the file does not exist, do not display a diagnostic message
        or modify the exit status to reflect an error.
    \item  \textbf{-i}: Request confirmation before attempting to remove each file,
        regardless of the file's permissions, or whether or not the standard input device
        is a terminal.
    \item  \textbf{-P}: Overwrite regular files before deleting them. Files are overwritten
        three times, first with the byte pattern 0xff, then 0x00, and then 0xff again, before
        they are deleted.
    \item  \textbf{-R}: Attempt to remove the file hierarchy rooted in each file argument.
        The -R option implies the -d option.
        If the -i option is specified, the user is prompted for confirmation before
        each directory's contents are processed (as well as before the attempt is
        made to remove the directory).
        If the user does not respond affirmatively, the file hierarchy rooted in that
        directory is skipped.
    \item  \textbf{-r}: Same as -R.
    \item  \textbf{-v}: Be verbose when deleting files, showing them as they are removed.
    \item  \textbf{-W}: Attempt to undelete the named files.
        Currently, this option can only be used to recover files covered by whiteouts.
\end{itemize}

Removing links

The rm utility removes symbolic links, not the files referenced by the links.\\
It is not allowed to remove the files "." or "..".\\

When the utility is called as unlink, only one argument, which must not be a directory,
may be supplied. No options may be supplied in this simple mode of operation,
which performs an unlink(2) operation on the passed argument.\\

The rm utility exits 0 if all of the named files or file hierarchies were removed,
or if the -f option was specified and all of the existing files or file hierarchies were removed.
If an error occurs, rm exits with a value 0.

\section{Relative paths}


\large Announ Marwan \normalsize\\



Relative path is defined as path related to the present working directory(pwd).\\
Suppose I am located in /home/user and I want to change directory to /home/user/Documents.\\
I can use relative path concept to change directory to Documents.

\begin{verbatim}
pwd
  /home/user
cd Documents
pwd
  /home/user/Documents
\end{verbatim}

If you observe, there is a little bit difference between absolute and relative paths:
in relative paths there is no "/" at the very beginning.\\
Meanwhile in an absolute path you have to write "/", in this case it'd be "/home/user/Documents".

\section{mkdir}


\large Mirko Ponzio \normalsize\\





The \texttt{mkdir} command is used to create new directories\\
The name stands for \emph{MaKe DIRectory}.\\

The default ls command syntax is:

\begin{verbatim}
mkdir [flags] [-m mode] directory_name ...
\end{verbatim}

Where \[flags\] are the mkdir \texttt{-p} and \texttt{-v} - flags,
read below for more info, and \emph{directory\_name} is the
name of the new directory we are going to create.\\

Create a new directory
Let's see how to create a new directory:

\begin{verbatim}
ls

mkdir test_directory
ls
    test_directory
\end{verbatim}

Create a path of directories
Using the flag \texttt{-p} we can create a path of directories, allowing us
to build more than a directory at once.

\begin{verbatim}
mkdir -p test_directory/subdir/subsubdir
\end{verbatim}

As you can see, we are now creating two directories: one named \emph{subdir} and
another one, included in this, named \emph{subsubdir}\\
The -p flag is necessary to allow the shell to create intermediate
directories as required.\\

Create directories with specified permissions
The \texttt{-m mode} option allows us to set permissions at the new directory
that we are now creating.

\begin{verbatim}
mkdir -m 777 test_free_directory
\end{verbatim}

Our new directory will now have read,write and execute permissions for user, group and others.

\section{cp}


\large Mattia Hijman \normalsize\\



The \texttt{cp} command copies the contents of one or more files or directories to a
target file or directory.\\

\begin{verbatim}
cp [source1] [source2] [source3] ... [target]
\end{verbatim}


Flags

\begin{itemize}
    \item \textbf{-a}: Same as -pPR options. Preserves structure and attributes of files
        but not directory structure.
    
    \item \textbf{-f}: If the destination file cannot be opened, remove it and create a new file,
        without prompting for confirmation regardless of its permissions.
        The target file is not unlinked before the copy,
        so any existing access rights will be retained.
    
    \item \textbf{-H}: If -R is specified, symbolic links on the command line are followed.
    \item \textbf{-i}: Cause cp to write a prompt to the standard error output before
        copying a file that would overwrite an existing file. If the
        response from the standard input begins with the character \emph{y} or
        \emph{Y}, the file copy is attempted.
    
    \item \textbf{-L}: If the -R option is specified, all symbolic links are followed.
    \item \textbf{-n}: Do not overwrite an existing file.
    \item \textbf{-P}: If the -R option is specified, no symbolic links are followed.
    \item \textbf{-p}: Cause cp to preserve the following attributes of each source file
        in the copy.
    
    \item \textbf{-R}: If source\_file designates a directory, cp copies the directory and
        the entire subtree connected at that point. If the source\_file
        ends in a /, the contents of the directory are copied rather than
        the directory itself.  This option also causes symbolic links to be
        copied, rather than indirected through, and for cp to create special files
        rather than copying them as normal files.
    
    \item \textbf{-v}: Cause cp to be verbose, showing files as they are copied.
    \item \textbf{-X}: Do not copy Extended Attributes (EAs) or resource forks.
\end{itemize}

\section{Absolute paths}


\large Announ Marwan \normalsize\\



A path is a location to a folder or file in a file system of a Operating System,
then is a combination of characters and "/".\\

An absolute path is defined as specifying the location of a file or directory
from the root directory (/).In other words we can say absolute path is a complete
path from start of actual filesystem from / directory.\\

To write an absolute path-name:

Start at the root directory ( / ) and work down.\\
Write a slash ( / ) after every directory name (last one is optional).\\

If for example, we the commands "cat group1.txt", it'll work only and only if the "group1.txt"
exist in the current directory.\\
If doesn't works, it's not a problem, you just have to know where the file is actually stored.\\
Now, we suppose that you know where your file is saved so you can rewrite the command.
"cat /home/a1/group1.txt".\\

As you can see from the last commands, the path started from "/" which is the root directory
for every Unix machines.\\

Here are some other examples of absolute paths:

\begin{itemize}
    \item /home/user/Document/group1.txt
    \item /root/data/dev.zip
    \item /var/log/messages
\end{itemize}

\section{touch}


\large Mattia Hijman \normalsize\\



The \texttt{touch} command updates the modification and access time of the a file.
If the given file does not exists, it gets created.\\

\begin{verbatim}
touch [flags] [file1] [file2] ...
\end{verbatim}

Flags

\begin{itemize}
    \item \textbf{-A}: adjust the access and modification timestamps for the file by the
        specified value.
    
    \item \textbf{-a}: Change the access time of the file. The modification time of the
        file is not changed unless the -m flag is also specified.
    
    \item \textbf{-c}: Do not create the file if it does not exist.
    \item \textbf{-f} Attempt to force the update, even if the file permissions do not
        currently permit it.
    
    \item \textbf{-h}: If the file is a symbolic link, change the times of the link
        itself rather than the file that the link points to.
    
     \item \textbf{-m}: Change the modification time of the file. The access time of the
        file is not changed unless the -a flag is also specified.
    
    \item \textbf{-t}: Change the access and modification times to the specified time
        instead of the current time of day.
    
\end{itemize}

\section{cd}


\large Alessandro Marinelli \normalsize\\







The \texttt{cd} command is used to change the working directory<br/>
The name stands for \emph{Change Directory}.<br/>

The default cd command syntax is:


\begin{verbatim}
cd [flags] [path]
\end{verbatim}



Where \[flags\] are the cd flags, read below for more info,and \[path\] is the
path (absolute or relative), of the directory which we  want to make as working directory.


Change the working directory


Let's see how to use the command \texttt{cd} in order to change the working directory:


\begin{verbatim}
pwd
    ~
cd Desktop/multimedia
pwd
    ~/Desktop/multimedia
\end{verbatim}



As you can see, we changed the working directory from ~ (which stands for HOME),
to "multimedia". Now our Shell will work on the  directory "multimedia"
until a new \texttt{cd} will occour.



\textbf{Notice:} If you want to move to a directory which is not contained in the
current working directory, you \underline{MUST} use the absolute path.


\section{Redirection}


\large Dario Rasic \normalsize\\


output as input
\\
To redirect a certain output of the command-line we have to use the symbol "\textgreater ".\\

In this case, we will use a file named \emph{hello.txt}, in which we want to insert
a certain output ("Sun" in this case):\\

\begin{verbatim}
echo "Sun" \textgreater  hello.txt
\end{verbatim}

So if we print the content of the file in our command-line, the output will be the following:

\begin{verbatim}
cat hello.txt
    Sun
\end{verbatim}

If we want to append a certain output to an existing file,
we just have to use "\textgreater \textgreater " symbols:

\begin{verbatim}
cat hello.txt
    Sun
echo "Moon" \textgreater \textgreater  hello.txt
cat hello.txt
    Sun
    Moon
\end{verbatim}


input as output
\\
To redirect an input from a file for a command, the symbol "\textless " is used.

\begin{verbatim}
echo $lt; $(cat hello.txt)
    Sun
    Moon
\end{verbatim}

This is particularly useful when chaining commands.\\


Chaining (or piping)

Chaining, also called Piping because it works with the pipe symbol "|", takes
the output of a certain command-line and feeds it to another command in a direct way.
\begin{verbatim}
cat hello.txt | grep Mo
Moon
\end{verbatim}

A simple example

Now let's say that we want to combine those commands in a more complex operation.
Let's say we want to take some contents from a certain file and put it into another file.\\

We want to sort the animals whose name begins with letter "d" from the file
\emph{animals.txt} and put it into \emph{d\_animals.txt}.\\

\begin{verbatim}
grep d \textless  animals.txt \textgreater  d_animals.txt
    cat d_animals.txt
    Deer
    Dog
    Dolphin
    ...
\end{verbatim}

\section{Script  Base Commands}


\large Dario Rasic \normalsize\\



Echo

This command print as output its entire argument on the command-line.\\
    It could be used with variables, like in the following example:\\

\begin{verbatim}
example="this is an example"

echo $example
    this is an example
\end{verbatim}


Cat

This command prints the content of a certain file as an output on the
command-line.\\

As example, we could imagine a simple text file in nano named "Hello", which contains
the line "Hello World".\\
So, our command example will look like this:\\

\begin{verbatim}
nano Hello
cat Hello
    Hello World
\end{verbatim}



Grep

This one behaves very similarly to the previus one, but in this case it prints only
the lines matching a certain pattern.\\
In this we could imagine a certain text file "animals", which contains a list of animal-names.

If we want to select only the animals whose name begins with the letter "d", we will write this:\\

\begin{verbatim}
grep "D" animals
    Deer
    Dragon
    Dinosaur
    Dog
    Dolphin
\end{verbatim}

\section{While Loop}


\large Matteo Omenetti \normalsize\\




Loops are an important concept in programming and therefore also in scripting.
Thanks to loops you are able to repeat an instruction
automatically several times, until a certain condition turns false.\\

Two are the main types of loops: while and for. They both generate a repeating
piece of code, but with some key differences
that make them suitable for different needs while programming.\\

While loops take this form:
\begin{verbatim}
while [condition]
do
    command1
    command2
    command3
    ...
done
\end{verbatim}



Here is a first simple example:
\begin{verbatim}
i=0;

while [$i -lt 4]
do
    echo $i
    i=$((i + 1))
done
\end{verbatim}

In this first example, you simply create a variable called i and evaluate it to 0.
Then you access the while loop: the condition \texttt{ \[\$i -lt 4\]} means that this while
loop will run until the \texttt{ i} variable is less than 4.
Every cycle of this loop, you print out the value of variable i with \texttt{ echo \$i}
and finally, you increase its value by 1 with \texttt{ i=\$((i + 1))}.
Therefore in 4 cycles the value of i will be 4. This will make the condition of the while loop false.
The output of this piece of code is:
\begin{verbatim}
    0
    1
    2
    3
 \end{verbatim}





Sometimes it is required to declare infinite loops for various programming purposes. \\
Here is an example:
\begin{verbatim}
i=1;

while :
do
    printf "i=$i\i: Hello World"
    if [ $i == 3 ]; then
        echo "I love DrRacket"
    elif [ $i == 5]; then
        echo "I love Bash"
    elif [ $i == 7 ]; then
        echo "I love this website"
    elif [ $i == 9 ]; then
        exit 0
    i=$((i + 1))
done
\end{verbatim}

No termination condition is set for this loop in this example. This type of loop
is called infinite loop.\\
The \texttt{ exit} statement is used to quit the loop. This loop will
iterate for 9 times, then
as soon as \texttt{ i} becomes equal to 0, the condition of the last if
statement will evaluate to true and the loop will be terminated. \\

The output of this piece of code is:
\begin{verbatim}
    1: Hello World
    2: Hello World
    3: Hello World
    I love programming
    4: Hello World
    5: Hello World
    I love Bash
    6: Hello World
    7: Hello World
    I love this website
    8: Hello World
    9: Hello World
\end{verbatim}




If you want your shell to hang forever doing nothing you can write out the following infinite loop:
\begin{verbatim}
while :
do
    :
done
\end{verbatim}



In scripting, while loops are often used to process files line by line. \\
Here is an example:
\begin{verbatim}
while read -r first_name last_name phone;
do
    printf '\%s\\n' "$last_name"
done \textless  "$file"
\end{verbatim}

The \texttt{ read } command is used to read a file line by line.
The flag \texttt{ -r} is used to tell the
command read to interpret backslashes (/) literally, instead as escape characters.
This command, expect for some few
rare cases, should always be used with this flag.
In this example, \texttt{ \textless  "\$file"} redirects the loop's input from a file
whose name is stored in a variable.
This file has 3 columns, \texttt{ first\_name last\_name phone }, separated by
blank space (or a tab).
This piece of code only prints out the second column.


\section{If statement}


\large Matteo Omenetti \normalsize\\




If statements allow us to make decisions in our Bash scripts. They allow us to
whether run or not a piece of code based on a condition that we set. \\

If statements take this form:
\begin{verbatim}
if [condition]; then
    command1
    command2
    command3
    ...
fi
\end{verbatim}

Anything between \texttt{then} and \texttt{fi} will be executed only if the condition
evaluates to true. \\
Here is a simple example:

\begin{verbatim}
i=210;

if [$i -ge 200]; then
    echo "You chose a big number."
 fi
\end{verbatim}

In this first example we evaluate a variable \texttt{i} to 105.
The \emph{ if statement } will print "You chose a big number"
only if the number contained in our variable \texttt{i} is \textbf{G}reater or
\textbf{E}qual to 200. \\
This is our case, therefore the output of this piece of code will be:
\begin{verbatim}
  You chose a big number.
\end{verbatim}




 If Else 

Sometimes we want to perform a certain set of actions, if our condition evaluates to
true and another set of actions if our condition evaluates to false. We can do this with
the \emph{ if else } statement.
\emph{ if else } sattements take this form:
\begin{verbatim}
if [condition]; then
    command1
    command2
    command3
    ...
else
    command1
    command2
    command3
    ...
fi
\end{verbatim}

Here is a simple example:
\begin{verbatim}
i=50;

if [$i -ge 200]; then
    echo "You chose a big number."
else
    echo "You chose a small number."
fi
\end{verbatim}

In this example, that is just an extension of the previous example, we
evaluate a variable \texttt{i} to 50. If \texttt{i} is greater or equal to
200, you print out "You chose a big number", otherwise,
(if \texttt{i} is not greater or equal to 200), just like in this case, you print out
"You chose a small number".
Therefore, the output of this piece of code is:

\begin{verbatim}
  You chose a small number.
\end{verbatim}




 If Elif Else 
Sometimes, in programming, it is necessary to have a series of conditions that lead to
different paths. We can accommodate this need with the \emph{if else elif} mechanism.
The \emph{if else elif} mechanism takes this form:

\begin{verbatim}
if [condition]; then
    command1
    command2
    command3
    ...
elif [condition]; then
    command1
    command2
    command3
    ...
else
    command1
    command2
    command3
    ...
fi
\end{verbatim}

Here is a simple example:

\begin{verbatim}
i=150;

if [$i -ge 200]; then
    echo "You chose a big number."
elif [$i == 150]; then
    echo "You chose 150".
else
    echo "You chose a small number"
fi
\end{verbatim}

In this example, that is just an extension of the previous example, we evaluate a
variable \texttt{i} to 150. If \texttt{i} is greater or equal to 200,
you print out "You chose a big number", if \texttt{i} is equal to 150 you print out
"You chose 150" otherwise you print out "You chose a small number".
Therefore, the output of this piece of code is:

\begin{verbatim}
  You chose 150.
\end{verbatim}

\section{For Loop}


\large Matteo Omenetti \normalsize\\




The second type of loops are for loops.
They follow this syntax:
\begin{verbatim}
  for [variable] in [list] do
    [code]
  done
\end{verbatim}

Their purpose is to \emph{iterate} over a list. Also, while loops could do this,
you might argue... \\
Of course, they could, but for loops are specifically meant to do this. Therefore, for instance,
you don't have to declare your counter variable outside the loop. Most importantly,
this variable can be accessed from inside the loop. \\

For loops take this form:
\begin{verbatim}
for VARIABLE in 1 2 3 4 5 .. N
do
    command1
    command2
    commandN
done
\end{verbatim}



Here is a simple example:
\begin{verbatim}
for i in 1 2 3 4 5
do
   echo "Welcome $i times"
done
\end{verbatim}

This first example of code simply displays a welcome message 5 times.
The output of this piece of code is:
\begin{verbatim}
    Welcome 1 times
    Welcome 2 times
    Welcome 3 times
    Welcome 4 times
    Welcome 5 times
\end{verbatim}



There are also other ways to specify the \emph{ numerical range }. For instance, if
your numerical range is too big, you can simply write: \texttt{ {1..100} }. This piece
of code means every natural number between 1 and 100 (both included). \\
Ranges can also count backward like this: \texttt{{10..1}}.
You can even increment the numerical value by step of two: \texttt{ {0..10..2} }.
This piece of code means every natural number between 0 and 10 with a step of two,
0 2 4 6... 10.


\section{Script Variables}


\large Dario Rasic \normalsize\\



A variable is simply a string to which we assign a certain type of data,
which could be a text, a number, a filename and other types of data.\\


Naming a variable


To name a variable in Unix we have to use only letters, numbers or
the underscore character (\_).\\
Other characters can't be used because they have a special meaning in Unix Shell.\\

Some simple examples are:

\begin{verbatim}
VAR_1
VAR_2
NAME_3
name_4
\end{verbatim}


Defining a variable

To define a certain variable, we could use the following basecase:

\begin{verbatim}
variable_name=variable_value
\end{verbatim}


Let me show you a simple example:

\begin{verbatim}
VAR_1=Strawberry
\end{verbatim}


To access a variable we have to use the dollar sign (\$). So if I want to
access VAR\_1, I have to write:

\begin{verbatim}
VAR_1="Strawberry"
echo $VAR_1
    Strawberry
\end{verbatim}


Deleting a variable

Deleting a variable means that shell will remove a certain variable from the list of
those that it tracks.\\
To delete a variable we use the following command:

\begin{verbatim}
unset variable_name
\end{verbatim}

which in our case would be:

\begin{verbatim}
unset VAR_1
\end{verbatim}


Protecting variables

To protect a certain variable, we can set them as read-only so that it can't be
changed or deleted.\\
So, if we try to change the value of VAR\_1, the result will be the following:

\begin{verbatim}
VAR_1="Strawberry"
readonly VAR_1
VAR_1="Blueberry"
    VAR_1: This variable is read only.
\end{verbatim}

If we try to delete the variable, shell will give us the following value:

\begin{verbatim}
VAR_1="Strawberry"
unset VAR_1
    VAR_1: This variable is read only.
\end{verbatim}

\section{Parameter expansion}


\large Marco Tereh \normalsize\\



There are some special operations that can be performed on
\underline{\href{variables.html}{variables}} and strings called parameter expansions.
The general syntax for all parameter expansions is this one:

\begin{verbatim}
  ${CODE_HERE}
\end{verbatim}

Depending on what you want to do with your variable, the code
that goes inside the braces differs.\\

\begin{verbatim}
  ${VARIABLE:-DEFAULT_VALUE}
\end{verbatim}

If the variable VARIABLE exists and has a value (i.e. it is not null), this is equal to
the value of VARIABLE.
Otherwise, it is equal to DEFAULT\_VALUE.\\

Example: \texttt{echo "First name: \${firstname:-John}";}\\

\begin{verbatim}
  ${VARIABLE:=DEFAULT_VALUE}
\end{verbatim}

If the variable VARIABLE exists and has a value, this is equal to the value of VARIABLE.
Otherwise, it sets the variable to DEFAULT\_VALUE and is equal to it.\\
Example: \texttt{echo "Last name: \${lastname:=Doe}";}\\

\begin{verbatim}
  ${VARIABLE:?ERR_VALUE}
\end{verbatim}

If the variable VARIABLE exists and has a value, this is equal to the value of VARIABLE.
Otherwise, it prints ERR\_VALUE to STDERR and exits (meaning nothing else will be executed
after this).\\
Example: \texttt{currdate=\${date:?Operation failed: date unknown};}\\

\begin{verbatim}
  ${VARIABLE:+VALUE}
\end{verbatim}

If the variable VARIABLE exists and has a value, this is equal to VALUE.
Otherwise, this has no effect.\\
Example: \texttt{echo -e "reading from address \$read.\${write:+\\nWARNING: read and write set
at the same time}";}\\

All of these can also be written without the colon, in which case their meaning changes to
"If the variable VARIABLE exists at all (even if it is null), this is ..."\\

\begin{verbatim}
  ${VARIABLE: NUMBER}
\end{verbatim}

This is equal to the substring of the value of VARIABLE, starting at the character with
(0-based) index NUMBER.\\
If NUMBER is negative, the substring starts NUMBER characters before the end of the string.\\
Example: \texttt{lastname=\${fullname:\$firstnamelength};}\\

\begin{verbatim}
  ${VARIABLE: FROM:LENGTH}
\end{verbatim}

This is equal to the substring of the value of VARIABLE, starting at the character with (0-based)
index FROM with length LENGTH\\
If FROM is negative, the substring starts FROM characters before the end of the string.\\
Example: \texttt{lastname=\${middlename:\$firstnamelength:\$middlenamelength};}\\

\begin{verbatim}
  ${#VARIABLE}
\end{verbatim}

This is equal to the length of the value of VARIABLE\\
Example: \texttt{echo "your name has \${\#name} characters";}\\

Paremeter expansions can also be nested, like this:

\begin{verbatim}
  ${input:?${INVALID_INPUT_ERR_MSG:-An unknown error occurred}}
\end{verbatim}

Further reading: <a href="http://www.gnu.org/software/bash/manual/bashref.html\#Shell-Parameter-Expansion">
the bash reference manual

\section{Script Special Variables}


\large Dario Rasic \normalsize\\



There are certain strings that we can not use in the variable-naming process.\\
In this page we will see what actually are those strings, and what's their purpose.\\

\$\$
To begin, we will see the simplest variable, which is the dollar sign (\$).
This command simply gives us the process ID number of the current shell.\\

\begin{verbatim}
echo $$
    11480
\end{verbatim}

\$0
This variable will simply give us the filename of the current script.

\$n
This variable corresponds to the arguments with which a script was invoked.
Here n is a positive number corresponding to the position of an argument.

\$\#
This variable gives us the number of arguments supplied to a script.

\$!
This variable gives us the process number of the last background command.

\section{Arrays}


\large Marco Tereh \normalsize\\



There is a special kind of \underline{\href{variables.html}{variable}}, called an array.\\

While variables hold a single value, arrays hold many. They could be called a list of variables.
The simplest way to create an array is using this format:

\begin{verbatim}
  names=("Anna" "Bob" "Clarice" "Dee")
\end{verbatim}

This will create an array, called \texttt{names}, which holds 4 values.
The values in the array can be accessed using the syntax

\begin{verbatim}
  ${names[SELECTOR]}
\end{verbatim}

where SELECTOR is the selector associated to the desired element. There are two kinds of
arrays, depending on what kind of selector is used.\\

\texttt{names} is an \emph{indexed} array, meaning the selector is a number.
Since we didn't specify any when we defined it, \texttt{names}' selectors start at
0 and count up from there.\\

Thus we can access the string \texttt{"Anna"} using \texttt{names\[0\]}.
In the same way we use \texttt{names\[1\]} to access \texttt{"Bob"} and so on.\\

If we want to specify a particular index for our values when creating the array
we can do it like this:

\begin{verbatim}
  names=([1]="Anna" [2]="Bob" [5]="Ernie" [12]="Luigi")
\end{verbatim}

As you might have guessed, this will create an array with \texttt{"Anna"} at index 1,
\texttt{"Bob"} at index 2, \texttt{"Ernie"} at index 3 and so on.\\

If our indices are all sequential and we just want to change the starting index, we can use

\begin{verbatim}
  names=([12]="Luigi" "Mario" "Nate")
\end{verbatim}

Which will create an array with \emph{"Luigi"} at index 12,
\emph{"Mario"} at index 13 and \emph{"Nate"} at index 14.\\
An indexed array's selector can also be negative, which will start counting from the end,
so \emph{\${names\[-1\]}} means \emph{"Nate"}, \texttt{\${names\[-3\]}} is
\emph{"Luigi"} and so on.\\

The other kind of array is an \emph{associative} array.
In an associative array, the values are not mapped to a number but to some other string.\\

Here's an example of an associative array:

\begin{verbatim}
  colors=([white]="#FFFFFF" [black]="#000000" [red]="#FF0000" [yellow]="#00FFFF")
\end{verbatim}

In this case it is not possible to omit the selector as there is no logical word
that "follows" white. To access its members, we use the same syntax but write a string
instead of a number as the selector.\\
Arrays, both kinds, can also be modified after creation. We can use

\begin{verbatim}
  colors[blue]="#0000FF"
\end{verbatim}

to add an element to the array (or modify it if it exists already) and

\begin{verbatim}
  unset colors[black]
\end{verbatim}

to remove one.\\

The \texttt{@} and \texttt{*} selectors are special - they cannot be written to but
reading from them will return \textbf{all} the values in the array, separated by spaces.
Similarly, \texttt{\${!colors\[@\]}} is a list of
all the selectors (or indices) that were assigned a value.\\

\underline{\href{parameter\_expansion.html}{Parameter Expansion}} works on indexed arrays as well,
much like it works on strings, but it manipulates the members of the array instead of characters.
For example:

\begin{verbatim}
  ${names[@]: 13}
\end{verbatim}

is equivalent to \texttt{"Mario" "Luigi"}, while

\begin{verbatim}
  ${#names[@]}
\end{verbatim}

counts the number of elements in the array, in this case 3.\\

Further reading: <a href="http://www.gnu.org/software/bash/manual/bashref.html\#Arrays">
the bash reference manual
\end{document}
